<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Discord Bot Configuration</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 10px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
            overflow: hidden;
        }
        
        header {
            background: #2c3e50;
            color: white;
            padding: 30px;
            text-align: center;
        }
        
        h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }
        
        .subtitle {
            opacity: 0.9;
            font-size: 1.1em;
        }
        
        .tabs {
            display: flex;
            background: #34495e;
            overflow-x: auto;
        }
        
        .tab {
            padding: 15px 30px;
            color: white;
            cursor: pointer;
            border: none;
            background: transparent;
            font-size: 16px;
            transition: background 0.3s;
            white-space: nowrap;
        }
        
        .tab:hover {
            background: rgba(255, 255, 255, 0.1);
        }
        
        .tab.active {
            background: white;
            color: #2c3e50;
        }
        
        .tab-content {
            padding: 30px;
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }
        
        .form-group {
            margin-bottom: 20px;
        }
        
        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #2c3e50;
        }
        
        input[type="text"],
        input[type="number"],
        textarea,
        select {
            width: 100%;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 5px;
            font-size: 14px;
            transition: border-color 0.3s;
        }
        
        input[type="text"]:focus,
        input[type="number"]:focus,
        textarea:focus,
        select:focus {
            outline: none;
            border-color: #667eea;
        }
        
        textarea {
            resize: vertical;
            min-height: 100px;
            font-family: monospace;
        }
        
        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.3s;
            margin-right: 10px;
        }
        
        .btn-primary {
            background: #667eea;
            color: white;
        }
        
        .btn-primary:hover {
            background: #5568d3;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }
        
        .btn-secondary {
            background: #95a5a6;
            color: white;
        }
        
        .btn-secondary:hover {
            background: #7f8c8d;
        }
        
        .btn-danger {
            background: #e74c3c;
            color: white;
        }
        
        .btn-danger:hover {
            background: #c0392b;
        }
        
        .btn-success {
            background: #27ae60;
            color: white;
        }
        
        .btn-success:hover {
            background: #229954;
        }
        
        .list-item {
            padding: 15px;
            background: #f8f9fa;
            border-radius: 5px;
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .list-item:hover {
            background: #e9ecef;
        }
        
        .message {
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
            display: none;
        }
        
        .message.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        
        .message.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        
        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
        }
        
        .slider-container {
            margin-bottom: 15px;
        }
        
        .slider-value {
            display: inline-block;
            min-width: 60px;
            text-align: right;
            font-weight: bold;
            color: #667eea;
        }
        
        input[type="range"] {
            width: calc(100% - 70px);
            margin-left: 10px;
        }
        
        .import-export {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }
        
        .json-display {
            background: #2c3e50;
            color: #ecf0f1;
            padding: 15px;
            border-radius: 5px;
            font-family: monospace;
            font-size: 12px;
            overflow-x: auto;
            max-height: 400px;
            overflow-y: auto;
        }
        
        .btn-sm {
            padding: 6px 12px;
            font-size: 14px;
        }
        
        .item {
            padding: 15px;
            background: #f8f9fa;
            border-radius: 5px;
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
        }
        
        .item:hover {
            background: #e9ecef;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>ðŸ¤– Discord Bot Configuration</h1>
            <p class="subtitle">Configure your Discord bot with OpenAI-compatible API, Presets, and Character Cards</p>
        </header>
        
        <div class="tabs">
            <button class="tab active" onclick="switchTab('config')">Configuration</button>
            <button class="tab" onclick="switchTab('presets')">Presets</button>
            <button class="tab" onclick="switchTab('characters')">Characters</button>
            <button class="tab" onclick="switchTab('user_characters')">User Characters</button>
            <button class="tab" onclick="switchTab('lorebook')">Lorebook</button>
        </div>
        
        <!-- Configuration Tab -->
        <div id="config" class="tab-content active">
            <div id="config-message" class="message"></div>
            <h2>Bot Configuration</h2>
            
            <div class="form-group">
                <label>Discord Bot Token</label>
                <input type="text" id="discord-token" placeholder="Your Discord bot token">
            </div>
            
            <h3>OpenAI API Configuration</h3>
            <div class="grid">
                <div class="form-group">
                    <label>API Key</label>
                    <input type="text" id="api-key" placeholder="Your API key">
                </div>
                
                <div class="form-group">
                    <label>Base URL</label>
                    <input type="text" id="base-url" placeholder="https://api.openai.com/v1">
                </div>
                
                <div class="form-group">
                    <label>Model</label>
                    <div style="display: flex; gap: 10px;">
                        <input type="text" id="model" list="model-list" placeholder="gpt-3.5-turbo" style="flex: 1;">
                        <datalist id="model-list"></datalist>
                        <button onclick="pullModels()" class="btn-secondary" style="white-space: nowrap;">Pull Models</button>
                    </div>
                    <div id="models-message" class="message" style="margin-top: 5px; display: none;"></div>
                </div>
            </div>
            
            <h3>Default Preset</h3>
            <div class="grid">
                <div class="form-group">
                    <label>System Prompt</label>
                    <textarea id="system-prompt" placeholder="You are a helpful AI assistant."></textarea>
                </div>
            </div>
            
            <div class="grid">
                <div class="slider-container">
                    <label>Temperature: <span class="slider-value" id="temp-value">0.7</span></label>
                    <input type="range" id="temperature" min="0" max="2" step="0.1" value="0.7" oninput="updateSlider('temp', this.value)">
                </div>
                
                <div class="slider-container">
                    <label>Max Tokens (Context): <span class="slider-value" id="tokens-value">2000</span></label>
                    <input type="range" id="max-tokens" min="100" max="200000" step="1000" value="2000" oninput="updateSlider('tokens', this.value)">
                </div>
                
                <div class="slider-container">
                    <label>Max Response Length: <span class="slider-value" id="response-length-value">2000</span></label>
                    <input type="range" id="max-response-length" min="100" max="16000" step="100" value="2000" oninput="updateSlider('response-length', this.value)">
                </div>
                
                <div class="slider-container">
                    <label>Top P: <span class="slider-value" id="topp-value">1.0</span></label>
                    <input type="range" id="top-p" min="0" max="1" step="0.05" value="1.0" oninput="updateSlider('topp', this.value)">
                </div>
                
                <div class="slider-container">
                    <label>Frequency Penalty: <span class="slider-value" id="freq-value">0.0</span></label>
                    <input type="range" id="frequency-penalty" min="0" max="2" step="0.1" value="0.0" oninput="updateSlider('freq', this.value)">
                </div>
                
                <div class="slider-container">
                    <label>Presence Penalty: <span class="slider-value" id="pres-value">0.0</span></label>
                    <input type="range" id="presence-penalty" min="0" max="2" step="0.1" value="0.0" oninput="updateSlider('pres', this.value)">
                </div>
            </div>
            
            <button class="btn btn-primary" onclick="saveConfig()">Save Configuration</button>
            <button class="btn btn-secondary" onclick="loadConfig()">Reload</button>
        </div>
        
        <!-- Presets Tab -->
        <div id="presets" class="tab-content">
            <div id="presets-message" class="message"></div>
            <h2>Presets Management</h2>
            
            <div class="form-group">
                <label>Preset Name</label>
                <input type="text" id="preset-name" placeholder="Enter preset name">
            </div>
            
            <div class="form-group">
                <label>System Prompt</label>
                <textarea id="preset-system-prompt" placeholder="You are a helpful AI assistant."></textarea>
            </div>
            
            <div class="grid">
                <div class="slider-container">
                    <label>Temperature: <span class="slider-value" id="preset-temp-value">0.7</span></label>
                    <input type="range" id="preset-temperature" min="0" max="2" step="0.1" value="0.7" oninput="updateSlider('preset-temp', this.value)">
                </div>
                
                <div class="slider-container">
                    <label>Max Tokens (Context): <span class="slider-value" id="preset-tokens-value">2000</span></label>
                    <input type="range" id="preset-max-tokens" min="100" max="200000" step="1000" value="2000" oninput="updateSlider('preset-tokens', this.value)">
                </div>
                
                <div class="slider-container">
                    <label>Max Response Length: <span class="slider-value" id="preset-response-length-value">2000</span></label>
                    <input type="range" id="preset-max-response-length" min="100" max="16000" step="100" value="2000" oninput="updateSlider('preset-response-length', this.value)">
                </div>
                
                <div class="slider-container">
                    <label>Top P: <span class="slider-value" id="preset-topp-value">1.0</span></label>
                    <input type="range" id="preset-top-p" min="0" max="1" step="0.05" value="1.0" oninput="updateSlider('preset-topp', this.value)">
                </div>
                
                <div class="slider-container">
                    <label>Frequency Penalty: <span class="slider-value" id="preset-freq-value">0.0</span></label>
                    <input type="range" id="preset-frequency-penalty" min="0" max="2" step="0.1" value="0.0" oninput="updateSlider('preset-freq', this.value)">
                </div>
                
                <div class="slider-container">
                    <label>Presence Penalty: <span class="slider-value" id="preset-pres-value">0.0</span></label>
                    <input type="range" id="preset-presence-penalty" min="0" max="2" step="0.1" value="0.0" oninput="updateSlider('preset-pres', this.value)">
                </div>
            </div>
            
            <button class="btn btn-primary" onclick="savePreset()">Save Preset</button>
            <button class="btn btn-secondary" onclick="loadPreset()">Load Preset</button>
            <button class="btn btn-success" onclick="exportPreset()">Export</button>
            <button class="btn btn-secondary" onclick="showImportPreset()">Import</button>
            
            <div id="import-preset-section" style="display: none; margin-top: 20px;">
                <div class="form-group">
                    <label>Import Preset (JSON)</label>
                    <textarea id="import-preset-json" placeholder='{"temperature": 0.7, ...}'></textarea>
                </div>
                <button class="btn btn-success" onclick="importPreset()">Import</button>
                <button class="btn btn-secondary" onclick="cancelImportPreset()">Cancel</button>
            </div>
            
            <h3 style="margin-top: 30px;">Available Presets</h3>
            <div id="presets-list"></div>
        </div>
        
        <!-- Characters Tab -->
        <div id="characters" class="tab-content">
            <div id="characters-message" class="message"></div>
            <h2>Character Cards Management</h2>
            
            <div class="form-group">
                <label>Character Name</label>
                <input type="text" id="character-name" placeholder="Enter character name">
            </div>
            
            <div class="grid">
                <div class="form-group">
                    <label>Display Name</label>
                    <input type="text" id="character-display-name" placeholder="Character's display name">
                </div>
                
                <div class="form-group">
                    <label>Personality</label>
                    <input type="text" id="character-personality" placeholder="Friendly, helpful, creative...">
                </div>
            </div>
            
            <div class="form-group">
                <label>Description</label>
                <textarea id="character-description" placeholder="Describe the character..."></textarea>
            </div>
            
            <div class="form-group">
                <label>Scenario</label>
                <textarea id="character-scenario" placeholder="The scenario or context for interactions..."></textarea>
            </div>
            
            <div class="form-group">
                <label>System Prompt (Optional - overrides description-based prompt)</label>
                <textarea id="character-system-prompt" placeholder="Custom system prompt..."></textarea>
            </div>
            
            <button class="btn btn-primary" onclick="saveCharacter()">Save Character</button>
            <button class="btn btn-secondary" onclick="loadCharacter()">Load Character</button>
            <button class="btn btn-success" onclick="exportCharacter()">Export</button>
            <button class="btn btn-secondary" onclick="showImportCharacter()">Import</button>
            
            <div id="import-character-section" style="display: none; margin-top: 20px;">
                <div class="form-group">
                    <label>Import Character (JSON)</label>
                    <textarea id="import-character-json" placeholder='{"name": "...", "description": "..."}'></textarea>
                </div>
                <button class="btn btn-success" onclick="importCharacter()">Import</button>
                <button class="btn btn-secondary" onclick="cancelImportCharacter()">Cancel</button>
            </div>
            
            <h3 style="margin-top: 30px;">Available Characters</h3>
            <div id="characters-list"></div>
        </div>
        
        <!-- User Characters Tab -->
        <div id="user_characters" class="tab-content">
            <div id="user-characters-message" class="message"></div>
            <h2>Saved Character Information</h2>
            <p style="margin-bottom: 20px; color: #666;">Save descriptions for user characters that will be used in roleplay. The AI will use these descriptions for context when those character names are mentioned.</p>
            
            <div class="form-group">
                <label>Character Name</label>
                <input type="text" id="user-character-name" placeholder="Enter character name (e.g., Alice, Bob)">
            </div>
            
            <div class="form-group">
                <label>Description (Physical appearance and traits)</label>
                <textarea id="user-character-description" placeholder="A brave warrior with long red hair, green eyes, wearing silver armor. Known for her courage and compassion..." rows="5"></textarea>
            </div>
            
            <button class="btn btn-primary" onclick="saveUserCharacter()">Save User Character</button>
            <button class="btn btn-secondary" onclick="loadUserCharacter()">Load User Character</button>
            <button class="btn btn-success" onclick="exportUserCharacters()">Export All</button>
            <button class="btn btn-secondary" onclick="showImportUserCharacters()">Import</button>
            
            <div id="import-user-characters-section" style="display: none; margin-top: 20px;">
                <div class="form-group">
                    <label>Import User Characters (JSON)</label>
                    <textarea id="import-user-characters-json" placeholder='{"Alice": {"name": "Alice", "description": "..."}, ...}'></textarea>
                </div>
                <button class="btn btn-success" onclick="importUserCharacters()">Import</button>
                <button class="btn btn-secondary" onclick="cancelImportUserCharacters()">Cancel</button>
            </div>
            
            <h3 style="margin-top: 30px;">Saved User Characters</h3>
            <div id="user-characters-list"></div>
        </div>
        
        <!-- Lorebook Tab -->
        <div id="lorebook" class="tab-content">
            <div id="lorebook-message" class="message"></div>
            <h2>Lorebook - World Information</h2>
            <p style="margin-bottom: 20px; color: #666;">Add world-building and lore information that the AI can use for context. Entries can be triggered by keywords or set to always be active.</p>
            
            <!-- Lorebook Management Section -->
            <div style="background: #f5f5f5; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                <h3 style="margin-top: 0;">Manage Lorebooks</h3>
                <div style="display: flex; gap: 10px; margin-bottom: 15px; align-items: center;">
                    <div class="form-group" style="flex: 1; margin: 0;">
                        <label>Active Lorebook</label>
                        <select id="lorebook-selector" onchange="onLorebookSelected()">
                            <option value="">Loading...</option>
                        </select>
                    </div>
                    <button class="btn btn-primary" onclick="showCreateLorebookDialog()" style="margin-top: 24px;">New Lorebook</button>
                </div>
                
                <div id="lorebook-info" style="display: none; margin-bottom: 15px;">
                    <div style="display: flex; gap: 10px; align-items: center; margin-bottom: 10px;">
                        <span style="font-weight: bold;" id="current-lorebook-name"></span>
                        <span style="color: #666;" id="current-lorebook-description"></span>
                        <label style="margin-left: auto; display: flex; align-items: center; gap: 5px;">
                            <input type="checkbox" id="lorebook-enabled" onchange="toggleCurrentLorebook()" style="width: auto; margin: 0;">
                            <span>Enabled</span>
                        </label>
                    </div>
                    <div style="display: flex; gap: 10px;">
                        <button class="btn btn-secondary btn-sm" onclick="exportCurrentLorebook()">Export This Lorebook</button>
                        <button class="btn btn-danger btn-sm" onclick="deleteCurrentLorebook()">Delete This Lorebook</button>
                    </div>
                </div>
                
                <div style="margin-top: 15px;">
                    <h4 style="margin: 10px 0;">All Lorebooks</h4>
                    <div id="lorebooks-list" style="max-height: 200px; overflow-y: auto;"></div>
                </div>
            </div>
            
            <!-- Create Lorebook Dialog -->
            <div id="create-lorebook-dialog" style="display: none; background: #fff; padding: 20px; border-radius: 8px; border: 2px solid #007bff; margin-bottom: 20px;">
                <h3>Create New Lorebook</h3>
                <div class="form-group">
                    <label>Lorebook Name</label>
                    <input type="text" id="new-lorebook-name" placeholder="e.g., Fantasy World, Sci-Fi Setting">
                </div>
                <div class="form-group">
                    <label>Description (optional)</label>
                    <input type="text" id="new-lorebook-description" placeholder="Brief description of this lorebook">
                </div>
                <button class="btn btn-primary" onclick="createLorebook()">Create</button>
                <button class="btn btn-secondary" onclick="cancelCreateLorebook()">Cancel</button>
            </div>
            
            <h3>Add/Edit Entry</h3>
            <div class="form-group">
                <label>Entry Key (Unique identifier)</label>
                <input type="text" id="lorebook-key" placeholder="e.g., Kingdom of Aldoria, Magic System, Character Background">
            </div>
            
            <div class="form-group">
                <label>Content (Lore information)</label>
                <textarea id="lorebook-content" placeholder="Describe the lore, world details, or information..." rows="6"></textarea>
            </div>
            
            <div class="form-group">
                <label>Keywords (comma-separated, optional)</label>
                <input type="text" id="lorebook-keywords" placeholder="e.g., kingdom, aldoria, magic">
                <small style="color: #666; display: block; margin-top: 5px;">Entry will appear when any keyword is mentioned in conversation</small>
            </div>
            
            <div class="form-group">
                <label>Activation Type</label>
                <select id="lorebook-activation-type" style="width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 5px; font-size: 14px;">
                    <option value="normal">Normal (Keyword-triggered)</option>
                    <option value="constant">Constant (Always active)</option>
                    <option value="vectorized">Vectorized (Semantic search - future)</option>
                </select>
                <small style="color: #666; display: block; margin-top: 5px;">
                    <strong>Normal:</strong> Entry appears when keywords are mentioned<br>
                    <strong>Constant:</strong> Entry is always included in conversations<br>
                    <strong>Vectorized:</strong> Entry uses semantic search (planned feature, currently works like Normal)
                </small>
            </div>
            
            <button class="btn btn-primary" onclick="saveLorebookEntry()">Save Entry</button>
            <button class="btn btn-secondary" onclick="clearLorebookForm()">Clear Form</button>
            <button class="btn btn-success" onclick="exportLorebook()">Export All</button>
            <button class="btn btn-secondary" onclick="showImportLorebook()">Import</button>
            
            <div id="import-lorebook-section" style="display: none; margin-top: 20px;">
                <div class="form-group">
                    <label>Import Lorebook (JSON)</label>
                    <textarea id="import-lorebook-json" placeholder='{"Entry Key": {"key": "...", "content": "...", "keywords": [], "activation_type": "normal"}, ...}'></textarea>
                </div>
                <div class="form-group">
                    <label style="display: flex; align-items: center; gap: 8px;">
                        <input type="checkbox" id="lorebook-merge" checked style="width: auto; margin: 0;">
                        <span>Merge with existing entries (uncheck to replace all)</span>
                    </label>
                </div>
                <button class="btn btn-success" onclick="importLorebook()">Import</button>
                <button class="btn btn-secondary" onclick="cancelImportLorebook()">Cancel</button>
            </div>
            
            <h3 style="margin-top: 30px;">Lorebook Entries</h3>
            <div id="lorebook-list"></div>
        </div>
    </div>
    
    <script>
        // Tab switching
        function switchTab(tabName) {
            const tabs = document.querySelectorAll('.tab');
            const contents = document.querySelectorAll('.tab-content');
            
            tabs.forEach(tab => tab.classList.remove('active'));
            contents.forEach(content => content.classList.remove('active'));
            
            event.target.classList.add('active');
            document.getElementById(tabName).classList.add('active');
            
            if (tabName === 'presets') {
                loadPresetsList();
            } else if (tabName === 'characters') {
                loadCharactersList();
            } else if (tabName === 'user_characters') {
                loadUserCharactersList();
            } else if (tabName === 'lorebook') {
                loadLorebookList();
            }
        }
        
        // Slider updates
        function updateSlider(name, value) {
            document.getElementById(name + '-value').textContent = value;
        }
        
        // Show messages
        function showMessage(elementId, message, type) {
            const msgEl = document.getElementById(elementId);
            msgEl.textContent = message;
            msgEl.className = 'message ' + type;
            msgEl.style.display = 'block';
            setTimeout(() => {
                msgEl.style.display = 'none';
            }, 5000);
        }
        
        // Configuration functions
        async function loadConfig() {
            try {
                const response = await fetch('/api/config');
                const config = await response.json();
                
                document.getElementById('discord-token').value = config.discord_token || '';
                document.getElementById('api-key').value = config.openai_config?.api_key || '';
                document.getElementById('base-url').value = config.openai_config?.base_url || '';
                document.getElementById('model').value = config.openai_config?.model || '';
                
                const preset = config.default_preset || {};
                document.getElementById('system-prompt').value = preset.system_prompt || '';
                document.getElementById('temperature').value = preset.temperature || 0.7;
                document.getElementById('max-tokens').value = preset.max_tokens || 2000;
                document.getElementById('max-response-length').value = preset.max_response_length || 2000;
                document.getElementById('top-p').value = preset.top_p || 1.0;
                document.getElementById('frequency-penalty').value = preset.frequency_penalty || 0.0;
                document.getElementById('presence-penalty').value = preset.presence_penalty || 0.0;
                
                updateSlider('temp', preset.temperature || 0.7);
                updateSlider('tokens', preset.max_tokens || 2000);
                updateSlider('response-length', preset.max_response_length || 2000);
                updateSlider('topp', preset.top_p || 1.0);
                updateSlider('freq', preset.frequency_penalty || 0.0);
                updateSlider('pres', preset.presence_penalty || 0.0);
                
                showMessage('config-message', 'Configuration loaded', 'success');
            } catch (error) {
                showMessage('config-message', 'Error loading configuration: ' + error.message, 'error');
            }
        }
        
        async function saveConfig() {
            try {
                const config = {
                    discord_token: document.getElementById('discord-token').value,
                    openai_config: {
                        api_key: document.getElementById('api-key').value,
                        base_url: document.getElementById('base-url').value,
                        model: document.getElementById('model').value
                    },
                    default_preset: {
                        system_prompt: document.getElementById('system-prompt').value,
                        temperature: parseFloat(document.getElementById('temperature').value),
                        max_tokens: parseInt(document.getElementById('max-tokens').value),
                        max_response_length: parseInt(document.getElementById('max-response-length').value),
                        top_p: parseFloat(document.getElementById('top-p').value),
                        frequency_penalty: parseFloat(document.getElementById('frequency-penalty').value),
                        presence_penalty: parseFloat(document.getElementById('presence-penalty').value)
                    }
                };
                
                const response = await fetch('/api/config', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify(config)
                });
                
                const result = await response.json();
                showMessage('config-message', result.message, result.status === 'success' ? 'success' : 'error');
            } catch (error) {
                showMessage('config-message', 'Error saving configuration: ' + error.message, 'error');
            }
        }
        
        async function pullModels() {
            try {
                const apiKey = document.getElementById('api-key').value;
                const baseUrl = document.getElementById('base-url').value;
                
                if (!apiKey || !baseUrl) {
                    showMessage('models-message', 'Please enter API key and Base URL first', 'error');
                    return;
                }
                
                showMessage('models-message', 'Fetching models...', 'success');
                
                const response = await fetch('/api/models', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        api_key: apiKey,
                        base_url: baseUrl
                    })
                });
                
                const result = await response.json();
                
                if (result.status === 'success') {
                    const modelList = document.getElementById('model-list');
                    modelList.innerHTML = '';
                    
                    result.models.forEach(model => {
                        const option = document.createElement('option');
                        option.value = model;
                        modelList.appendChild(option);
                    });
                    
                    showMessage('models-message', `Found ${result.models.length} models`, 'success');
                } else {
                    showMessage('models-message', result.message, 'error');
                }
            } catch (error) {
                showMessage('models-message', 'Error fetching models: ' + error.message, 'error');
            }
        }
        
        // Preset functions
        async function loadPresetsList() {
            try {
                const response = await fetch('/api/presets');
                const data = await response.json();
                
                const listEl = document.getElementById('presets-list');
                listEl.innerHTML = '';
                
                if (data.presets.length === 0) {
                    listEl.innerHTML = '<p>No presets available</p>';
                    return;
                }
                
                data.presets.forEach(preset => {
                    const item = document.createElement('div');
                    item.className = 'list-item';
                    item.innerHTML = `
                        <span>${preset}</span>
                        <div>
                            <button class="btn btn-secondary" onclick="selectPreset('${preset}')">Load</button>
                            <button class="btn btn-danger" onclick="deletePreset('${preset}')">Delete</button>
                        </div>
                    `;
                    listEl.appendChild(item);
                });
            } catch (error) {
                console.error('Error loading presets:', error);
            }
        }
        
        async function selectPreset(name) {
            try {
                const response = await fetch(`/api/presets/${name}`);
                const preset = await response.json();
                
                document.getElementById('preset-name').value = name;
                document.getElementById('preset-system-prompt').value = preset.system_prompt || '';
                document.getElementById('preset-temperature').value = preset.temperature || 0.7;
                document.getElementById('preset-max-tokens').value = preset.max_tokens || 2000;
                document.getElementById('preset-max-response-length').value = preset.max_response_length || 2000;
                document.getElementById('preset-top-p').value = preset.top_p || 1.0;
                document.getElementById('preset-frequency-penalty').value = preset.frequency_penalty || 0.0;
                document.getElementById('preset-presence-penalty').value = preset.presence_penalty || 0.0;
                
                updateSlider('preset-temp', preset.temperature || 0.7);
                updateSlider('preset-tokens', preset.max_tokens || 2000);
                updateSlider('preset-response-length', preset.max_response_length || 2000);
                updateSlider('preset-topp', preset.top_p || 1.0);
                updateSlider('preset-freq', preset.frequency_penalty || 0.0);
                updateSlider('preset-pres', preset.presence_penalty || 0.0);
                
                showMessage('presets-message', `Loaded preset: ${name}`, 'success');
            } catch (error) {
                showMessage('presets-message', 'Error loading preset: ' + error.message, 'error');
            }
        }
        
        async function savePreset() {
            const name = document.getElementById('preset-name').value;
            if (!name) {
                showMessage('presets-message', 'Please enter a preset name', 'error');
                return;
            }
            
            try {
                const preset = {
                    system_prompt: document.getElementById('preset-system-prompt').value,
                    temperature: parseFloat(document.getElementById('preset-temperature').value),
                    max_tokens: parseInt(document.getElementById('preset-max-tokens').value),
                    max_response_length: parseInt(document.getElementById('preset-max-response-length').value),
                    top_p: parseFloat(document.getElementById('preset-top-p').value),
                    frequency_penalty: parseFloat(document.getElementById('preset-frequency-penalty').value),
                    presence_penalty: parseFloat(document.getElementById('preset-presence-penalty').value)
                };
                
                const response = await fetch(`/api/presets/${name}`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify(preset)
                });
                
                const result = await response.json();
                showMessage('presets-message', result.message, result.status === 'success' ? 'success' : 'error');
                loadPresetsList();
            } catch (error) {
                showMessage('presets-message', 'Error saving preset: ' + error.message, 'error');
            }
        }
        
        async function deletePreset(name) {
            if (!confirm(`Delete preset "${name}"?`)) return;
            
            try {
                const response = await fetch(`/api/presets/${name}`, {
                    method: 'DELETE'
                });
                
                const result = await response.json();
                showMessage('presets-message', result.message, result.status === 'success' ? 'success' : 'error');
                loadPresetsList();
            } catch (error) {
                showMessage('presets-message', 'Error deleting preset: ' + error.message, 'error');
            }
        }
        
        async function exportPreset() {
            const name = document.getElementById('preset-name').value;
            if (!name) {
                showMessage('presets-message', 'Please select a preset to export', 'error');
                return;
            }
            
            try {
                const response = await fetch(`/api/presets/${name}/export`);
                const data = await response.json();
                
                const blob = new Blob([data.preset], {type: 'application/json'});
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${name}.json`;
                a.click();
                
                showMessage('presets-message', 'Preset exported', 'success');
            } catch (error) {
                showMessage('presets-message', 'Error exporting preset: ' + error.message, 'error');
            }
        }
        
        function showImportPreset() {
            document.getElementById('import-preset-section').style.display = 'block';
        }
        
        function cancelImportPreset() {
            document.getElementById('import-preset-section').style.display = 'none';
            document.getElementById('import-preset-json').value = '';
        }
        
        async function importPreset() {
            const name = document.getElementById('preset-name').value;
            const presetJson = document.getElementById('import-preset-json').value;
            
            if (!name || !presetJson) {
                showMessage('presets-message', 'Please enter preset name and JSON', 'error');
                return;
            }
            
            try {
                const response = await fetch('/api/presets/import', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({name, preset: presetJson})
                });
                
                const result = await response.json();
                showMessage('presets-message', result.message, result.status === 'success' ? 'success' : 'error');
                cancelImportPreset();
                loadPresetsList();
            } catch (error) {
                showMessage('presets-message', 'Error importing preset: ' + error.message, 'error');
            }
        }
        
        // Character functions
        async function loadCharactersList() {
            try {
                const response = await fetch('/api/characters');
                const data = await response.json();
                
                const listEl = document.getElementById('characters-list');
                listEl.innerHTML = '';
                
                if (data.characters.length === 0) {
                    listEl.innerHTML = '<p>No characters available</p>';
                    return;
                }
                
                data.characters.forEach(character => {
                    const item = document.createElement('div');
                    item.className = 'list-item';
                    item.innerHTML = `
                        <span>${character}</span>
                        <div>
                            <button class="btn btn-secondary" onclick="selectCharacter('${character}')">Load</button>
                            <button class="btn btn-danger" onclick="deleteCharacter('${character}')">Delete</button>
                        </div>
                    `;
                    listEl.appendChild(item);
                });
            } catch (error) {
                console.error('Error loading characters:', error);
            }
        }
        
        async function selectCharacter(name) {
            try {
                const response = await fetch(`/api/characters/${name}`);
                const character = await response.json();
                
                document.getElementById('character-name').value = name;
                document.getElementById('character-display-name').value = character.name || '';
                document.getElementById('character-personality').value = character.personality || '';
                document.getElementById('character-description').value = character.description || '';
                document.getElementById('character-scenario').value = character.scenario || '';
                document.getElementById('character-system-prompt').value = character.system_prompt || '';
                
                showMessage('characters-message', `Loaded character: ${name}`, 'success');
            } catch (error) {
                showMessage('characters-message', 'Error loading character: ' + error.message, 'error');
            }
        }
        
        async function saveCharacter() {
            const name = document.getElementById('character-name').value;
            if (!name) {
                showMessage('characters-message', 'Please enter a character name', 'error');
                return;
            }
            
            try {
                const character = {
                    name: document.getElementById('character-display-name').value,
                    personality: document.getElementById('character-personality').value,
                    description: document.getElementById('character-description').value,
                    scenario: document.getElementById('character-scenario').value,
                    system_prompt: document.getElementById('character-system-prompt').value
                };
                
                const response = await fetch(`/api/characters/${name}`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify(character)
                });
                
                const result = await response.json();
                showMessage('characters-message', result.message, result.status === 'success' ? 'success' : 'error');
                loadCharactersList();
            } catch (error) {
                showMessage('characters-message', 'Error saving character: ' + error.message, 'error');
            }
        }
        
        async function deleteCharacter(name) {
            if (!confirm(`Delete character "${name}"?`)) return;
            
            try {
                const response = await fetch(`/api/characters/${name}`, {
                    method: 'DELETE'
                });
                
                const result = await response.json();
                showMessage('characters-message', result.message, result.status === 'success' ? 'success' : 'error');
                loadCharactersList();
            } catch (error) {
                showMessage('characters-message', 'Error deleting character: ' + error.message, 'error');
            }
        }
        
        async function exportCharacter() {
            const name = document.getElementById('character-name').value;
            if (!name) {
                showMessage('characters-message', 'Please select a character to export', 'error');
                return;
            }
            
            try {
                const response = await fetch(`/api/characters/${name}/export`);
                const data = await response.json();
                
                const blob = new Blob([data.character], {type: 'application/json'});
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${name}.json`;
                a.click();
                
                showMessage('characters-message', 'Character exported', 'success');
            } catch (error) {
                showMessage('characters-message', 'Error exporting character: ' + error.message, 'error');
            }
        }
        
        function showImportCharacter() {
            document.getElementById('import-character-section').style.display = 'block';
        }
        
        function cancelImportCharacter() {
            document.getElementById('import-character-section').style.display = 'none';
            document.getElementById('import-character-json').value = '';
        }
        
        async function importCharacter() {
            const name = document.getElementById('character-name').value;
            const characterJson = document.getElementById('import-character-json').value;
            
            if (!name || !characterJson) {
                showMessage('characters-message', 'Please enter character name and JSON', 'error');
                return;
            }
            
            try {
                const response = await fetch('/api/characters/import', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({name, character: characterJson})
                });
                
                const result = await response.json();
                showMessage('characters-message', result.message, result.status === 'success' ? 'success' : 'error');
                cancelImportCharacter();
                loadCharactersList();
            } catch (error) {
                showMessage('characters-message', 'Error importing character: ' + error.message, 'error');
            }
        }
        
        // User Characters Management
        async function loadUserCharactersList() {
            try {
                const response = await fetch('/api/user_characters');
                const data = await response.json();
                const characters = data.characters;
                
                const listEl = document.getElementById('user-characters-list');
                listEl.innerHTML = '';
                
                const characterNames = Object.keys(characters);
                if (characterNames.length === 0) {
                    listEl.innerHTML = '<p style="color: #999;">No user characters saved yet.</p>';
                    return;
                }
                
                characterNames.forEach(name => {
                    const charData = characters[name];
                    const item = document.createElement('div');
                    item.style.cssText = 'background: #f8f9fa; padding: 15px; margin: 10px 0; border-radius: 5px; border-left: 4px solid #667eea;';
                    
                    const description = charData.description.length > 150 ? 
                        charData.description.substring(0, 150) + '...' : 
                        charData.description;
                    
                    item.innerHTML = `
                        <div style="display: flex; justify-content: space-between; align-items: start;">
                            <div style="flex: 1;">
                                <strong style="font-size: 1.1em; color: #2c3e50;">${name}</strong>
                                <p style="margin: 5px 0 0 0; color: #666;">${description}</p>
                            </div>
                            <div style="display: flex; gap: 5px;">
                                <button class="btn btn-secondary" style="padding: 5px 10px; font-size: 0.9em;" onclick="editUserCharacter('${name}')">Edit</button>
                                <button class="btn btn-danger" style="padding: 5px 10px; font-size: 0.9em;" onclick="deleteUserCharacter('${name}')">Delete</button>
                            </div>
                        </div>
                    `;
                    listEl.appendChild(item);
                });
            } catch (error) {
                showMessage('user-characters-message', 'Error loading user characters: ' + error.message, 'error');
            }
        }
        
        async function saveUserCharacter() {
            const name = document.getElementById('user-character-name').value;
            const description = document.getElementById('user-character-description').value;
            
            if (!name || !description) {
                showMessage('user-characters-message', 'Please enter both name and description', 'error');
                return;
            }
            
            try {
                const response = await fetch(`/api/user_characters/${name}`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({description})
                });
                
                const result = await response.json();
                showMessage('user-characters-message', result.message, result.status === 'success' ? 'success' : 'error');
                loadUserCharactersList();
                
                // Clear form
                document.getElementById('user-character-name').value = '';
                document.getElementById('user-character-description').value = '';
            } catch (error) {
                showMessage('user-characters-message', 'Error saving user character: ' + error.message, 'error');
            }
        }
        
        async function loadUserCharacter() {
            const name = document.getElementById('user-character-name').value;
            
            if (!name) {
                showMessage('user-characters-message', 'Please enter a character name', 'error');
                return;
            }
            
            try {
                const response = await fetch(`/api/user_characters/${name}`);
                if (!response.ok) {
                    showMessage('user-characters-message', 'User character not found', 'error');
                    return;
                }
                
                const charData = await response.json();
                document.getElementById('user-character-name').value = charData.name;
                document.getElementById('user-character-description').value = charData.description;
                showMessage('user-characters-message', 'User character loaded', 'success');
            } catch (error) {
                showMessage('user-characters-message', 'Error loading user character: ' + error.message, 'error');
            }
        }
        
        async function editUserCharacter(name) {
            try {
                const response = await fetch(`/api/user_characters/${name}`);
                const charData = await response.json();
                
                document.getElementById('user-character-name').value = charData.name;
                document.getElementById('user-character-description').value = charData.description;
                
                // Scroll to form
                document.getElementById('user-character-name').scrollIntoView({ behavior: 'smooth' });
                showMessage('user-characters-message', 'Editing user character: ' + name, 'success');
            } catch (error) {
                showMessage('user-characters-message', 'Error loading user character: ' + error.message, 'error');
            }
        }
        
        async function deleteUserCharacter(name) {
            if (!confirm(`Delete user character "${name}"?`)) {
                return;
            }
            
            try {
                const response = await fetch(`/api/user_characters/${name}`, {
                    method: 'DELETE'
                });
                
                const result = await response.json();
                showMessage('user-characters-message', result.message, result.status === 'success' ? 'success' : 'error');
                loadUserCharactersList();
            } catch (error) {
                showMessage('user-characters-message', 'Error deleting user character: ' + error.message, 'error');
            }
        }
        
        async function exportUserCharacters() {
            try {
                const response = await fetch('/api/user_characters/export');
                const data = await response.json();
                
                const blob = new Blob([data.characters], {type: 'application/json'});
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'user_characters.json';
                a.click();
                
                showMessage('user-characters-message', 'User characters exported', 'success');
            } catch (error) {
                showMessage('user-characters-message', 'Error exporting user characters: ' + error.message, 'error');
            }
        }
        
        function showImportUserCharacters() {
            document.getElementById('import-user-characters-section').style.display = 'block';
        }
        
        function cancelImportUserCharacters() {
            document.getElementById('import-user-characters-section').style.display = 'none';
            document.getElementById('import-user-characters-json').value = '';
        }
        
        async function importUserCharacters() {
            const charactersJson = document.getElementById('import-user-characters-json').value;
            
            if (!charactersJson) {
                showMessage('user-characters-message', 'Please enter JSON data', 'error');
                return;
            }
            
            try {
                const response = await fetch('/api/user_characters/import', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({characters: charactersJson})
                });
                
                const result = await response.json();
                showMessage('user-characters-message', result.message, result.status === 'success' ? 'success' : 'error');
                cancelImportUserCharacters();
                loadUserCharactersList();
            } catch (error) {
                showMessage('user-characters-message', 'Error importing user characters: ' + error.message, 'error');
            }
        }
        
        // Lorebook Management
        async function loadLorebookList() {
            // Load the lorebooks list first
            await loadLorebooksList();
            
            // Then load entries if a lorebook is selected
            if (currentLorebookName) {
                await loadLorebookEntriesForCurrent();
            }
        }
        
        async function saveLorebookEntry() {
            const key = document.getElementById('lorebook-key').value.trim();
            const content = document.getElementById('lorebook-content').value.trim();
            const keywordsStr = document.getElementById('lorebook-keywords').value.trim();
            const activationType = document.getElementById('lorebook-activation-type').value;
            
            if (!key || !content) {
                showMessage('lorebook-message', 'Please enter both key and content', 'error');
                return;
            }
            
            // Ensure we have a lorebook selected
            if (!currentLorebookName) {
                showMessage('lorebook-message', 'Please select or create a lorebook first', 'error');
                return;
            }
            
            const keywords = keywordsStr ? keywordsStr.split(',').map(k => k.trim()).filter(k => k) : [];
            
            try {
                const response = await fetch(`/api/lorebook/${encodeURIComponent(key)}`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        content: content,
                        keywords: keywords,
                        activation_type: activationType,
                        lorebook_name: currentLorebookName
                    })
                });
                
                const result = await response.json();
                showMessage('lorebook-message', result.message, result.status === 'success' ? 'success' : 'error');
                clearLorebookForm();
                loadLorebookEntriesForCurrent();
                loadLorebooksList(); // Refresh to update entry count
            } catch (error) {
                showMessage('lorebook-message', 'Error saving entry: ' + error.message, 'error');
            }
        }
        
        async function editLorebookEntry(key) {
            if (!currentLorebookName) return;
            
            try {
                const response = await fetch(`/api/lorebooks/${encodeURIComponent(currentLorebookName)}`);
                const lorebook = await response.json();
                const entry = lorebook.entries[key];
                
                if (!entry) {
                    showMessage('lorebook-message', 'Entry not found', 'error');
                    return;
                }
                
                document.getElementById('lorebook-key').value = entry.key;
                document.getElementById('lorebook-content').value = entry.content;
                document.getElementById('lorebook-keywords').value = (entry.keywords || []).join(', ');
                
                // Handle activation_type with backward compatibility
                let activationType = entry.activation_type;
                if (!activationType) {
                    // Fall back to always_active for old entries
                    activationType = entry.always_active ? 'constant' : 'normal';
                }
                document.getElementById('lorebook-activation-type').value = activationType;
                
                // Scroll to top
                document.getElementById('lorebook').scrollTop = 0;
            } catch (error) {
                showMessage('lorebook-message', 'Error loading entry: ' + error.message, 'error');
            }
        }
        
        async function deleteLorebookEntry(key) {
            if (!currentLorebookName) return;
            
            if (!confirm(`Delete lorebook entry "${key}"?`)) {
                return;
            }
            
            try {
                const response = await fetch(`/api/lorebook/${encodeURIComponent(key)}`, {
                    method: 'DELETE'
                });
                
                const result = await response.json();
                showMessage('lorebook-message', result.message, result.status === 'success' ? 'success' : 'error');
                loadLorebookEntriesForCurrent();
                loadLorebooksList(); // Refresh to update entry count
            } catch (error) {
                showMessage('lorebook-message', 'Error deleting entry: ' + error.message, 'error');
            }
        }
        
        function clearLorebookForm() {
            document.getElementById('lorebook-key').value = '';
            document.getElementById('lorebook-content').value = '';
            document.getElementById('lorebook-keywords').value = '';
            document.getElementById('lorebook-activation-type').value = 'normal';
        }
        
        async function exportLorebook() {
            try {
                const response = await fetch('/api/lorebook/export');
                const data = await response.json();
                
                const blob = new Blob([data.lorebook], {type: 'application/json'});
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'lorebook.json';
                a.click();
                
                showMessage('lorebook-message', 'Lorebook exported successfully', 'success');
            } catch (error) {
                showMessage('lorebook-message', 'Error exporting lorebook: ' + error.message, 'error');
            }
        }
        
        function showImportLorebook() {
            document.getElementById('import-lorebook-section').style.display = 'block';
        }
        
        function cancelImportLorebook() {
            document.getElementById('import-lorebook-section').style.display = 'none';
            document.getElementById('import-lorebook-json').value = '';
        }
        
        async function importLorebook() {
            const lorebookJson = document.getElementById('import-lorebook-json').value;
            const merge = document.getElementById('lorebook-merge').checked;
            
            if (!lorebookJson) {
                showMessage('lorebook-message', 'Please enter JSON data', 'error');
                return;
            }
            
            try {
                const response = await fetch('/api/lorebook/import', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        lorebook: lorebookJson,
                        merge: merge
                    })
                });
                
                const result = await response.json();
                showMessage('lorebook-message', result.message, result.status === 'success' ? 'success' : 'error');
                cancelImportLorebook();
                loadLorebooksList();
                loadLorebookList();
            } catch (error) {
                showMessage('lorebook-message', 'Error importing lorebook: ' + error.message, 'error');
            }
        }
        
        // Multiple Lorebooks Management
        let currentLorebookName = null;
        
        async function loadLorebooksList() {
            try {
                const response = await fetch('/api/lorebooks');
                const data = await response.json();
                const lorebooks = data.lorebooks || [];
                
                // Update selector
                const selector = document.getElementById('lorebook-selector');
                selector.innerHTML = '<option value="">-- Select a Lorebook --</option>';
                
                lorebooks.forEach(lb => {
                    const option = document.createElement('option');
                    option.value = lb.name;
                    option.textContent = `${lb.name} (${lb.entry_count} entries)${lb.enabled ? '' : ' [Disabled]'}`;
                    selector.appendChild(option);
                });
                
                // Select first lorebook if available and none selected
                if (!currentLorebookName && lorebooks.length > 0) {
                    currentLorebookName = lorebooks[0].name;
                    selector.value = currentLorebookName;
                    await onLorebookSelected();
                }
                
                // Update lorebooks list
                const listDiv = document.getElementById('lorebooks-list');
                listDiv.innerHTML = '';
                
                if (lorebooks.length === 0) {
                    listDiv.innerHTML = '<p style="color: #666;">No lorebooks created yet.</p>';
                    return;
                }
                
                lorebooks.forEach(lb => {
                    const itemDiv = document.createElement('div');
                    itemDiv.style.cssText = 'padding: 8px; margin: 4px 0; background: white; border-radius: 4px; display: flex; justify-content: space-between; align-items: center;';
                    
                    const statusColor = lb.enabled ? '#28a745' : '#dc3545';
                    const statusText = lb.enabled ? 'Enabled' : 'Disabled';
                    
                    itemDiv.innerHTML = `
                        <div>
                            <strong>${lb.name}</strong>
                            <span style="color: ${statusColor}; margin-left: 10px; font-size: 0.9em;">â— ${statusText}</span>
                            <div style="color: #666; font-size: 0.9em;">${lb.description || 'No description'} - ${lb.entry_count} entries</div>
                        </div>
                        <button class="btn btn-sm btn-secondary" onclick="selectLorebook('${lb.name}')">Select</button>
                    `;
                    listDiv.appendChild(itemDiv);
                });
            } catch (error) {
                showMessage('lorebook-message', 'Error loading lorebooks: ' + error.message, 'error');
            }
        }
        
        async function onLorebookSelected() {
            const selector = document.getElementById('lorebook-selector');
            const name = selector.value;
            
            if (!name) {
                document.getElementById('lorebook-info').style.display = 'none';
                currentLorebookName = null;
                return;
            }
            
            currentLorebookName = name;
            
            try {
                const response = await fetch(`/api/lorebooks/${encodeURIComponent(name)}`);
                const lorebook = await response.json();
                
                document.getElementById('current-lorebook-name').textContent = lorebook.name;
                document.getElementById('current-lorebook-description').textContent = lorebook.description || '';
                document.getElementById('lorebook-enabled').checked = lorebook.enabled || false;
                document.getElementById('lorebook-info').style.display = 'block';
                
                // Load entries for this lorebook
                loadLorebookEntriesForCurrent();
            } catch (error) {
                showMessage('lorebook-message', 'Error loading lorebook: ' + error.message, 'error');
            }
        }
        
        async function loadLorebookEntriesForCurrent() {
            if (!currentLorebookName) return;
            
            try {
                const response = await fetch(`/api/lorebooks/${encodeURIComponent(currentLorebookName)}`);
                const lorebook = await response.json();
                const entries = lorebook.entries || {};
                
                const listDiv = document.getElementById('lorebook-list');
                listDiv.innerHTML = '';
                
                if (Object.keys(entries).length === 0) {
                    listDiv.innerHTML = '<p style="color: #666;">No entries in this lorebook yet.</p>';
                    return;
                }
                
                for (const [key, entry] of Object.entries(entries)) {
                    const entryDiv = document.createElement('div');
                    entryDiv.className = 'item';
                    
                    // Get activation type with backward compatibility
                    let activationType = entry.activation_type;
                    if (!activationType) {
                        activationType = entry.always_active ? 'constant' : 'normal';
                    }
                    
                    let statusText = '';
                    // Display activation type with color coding
                    if (activationType === 'constant') {
                        statusText += '<span style="color: #28a745; font-weight: bold;">â— Constant (Always Active)</span>';
                    } else if (activationType === 'vectorized') {
                        statusText += '<span style="color: #007bff; font-weight: bold;">â— Vectorized (Semantic)</span>';
                    } else {
                        statusText += '<span style="color: #6c757d; font-weight: bold;">â— Normal (Keyword)</span>';
                    }
                    
                    if (entry.keywords && entry.keywords.length > 0) {
                        statusText += (statusText ? ' | ' : '') + `Keywords: ${entry.keywords.join(', ')}`;
                    }
                    
                    entryDiv.innerHTML = `
                        <div>
                            <strong>${key}</strong>
                            ${statusText ? `<div style="font-size: 0.9em; color: #666; margin-top: 4px;">${statusText}</div>` : ''}
                            <div style="margin-top: 8px; color: #333;">${entry.content.substring(0, 150)}${entry.content.length > 150 ? '...' : ''}</div>
                        </div>
                        <div style="display: flex; gap: 8px;">
                            <button class="btn btn-sm btn-secondary" onclick="editLorebookEntry('${key}')">Edit</button>
                            <button class="btn btn-sm btn-danger" onclick="deleteLorebookEntry('${key}')">Delete</button>
                        </div>
                    `;
                    listDiv.appendChild(entryDiv);
                }
            } catch (error) {
                showMessage('lorebook-message', 'Error loading entries: ' + error.message, 'error');
            }
        }
        
        function selectLorebook(name) {
            document.getElementById('lorebook-selector').value = name;
            onLorebookSelected();
        }
        
        async function toggleCurrentLorebook() {
            if (!currentLorebookName) return;
            
            try {
                const response = await fetch(`/api/lorebooks/${encodeURIComponent(currentLorebookName)}/toggle`, {
                    method: 'POST'
                });
                
                const result = await response.json();
                showMessage('lorebook-message', result.message, result.status === 'success' ? 'success' : 'error');
                loadLorebooksList();
            } catch (error) {
                showMessage('lorebook-message', 'Error toggling lorebook: ' + error.message, 'error');
            }
        }
        
        function showCreateLorebookDialog() {
            document.getElementById('create-lorebook-dialog').style.display = 'block';
            document.getElementById('new-lorebook-name').value = '';
            document.getElementById('new-lorebook-description').value = '';
        }
        
        function cancelCreateLorebook() {
            document.getElementById('create-lorebook-dialog').style.display = 'none';
        }
        
        async function createLorebook() {
            const name = document.getElementById('new-lorebook-name').value.trim();
            const description = document.getElementById('new-lorebook-description').value.trim();
            
            if (!name) {
                showMessage('lorebook-message', 'Please enter a lorebook name', 'error');
                return;
            }
            
            try {
                const response = await fetch('/api/lorebooks', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        name: name,
                        description: description,
                        enabled: true
                    })
                });
                
                const result = await response.json();
                showMessage('lorebook-message', result.message, result.status === 'success' ? 'success' : 'error');
                cancelCreateLorebook();
                loadLorebooksList();
                
                // Select the newly created lorebook
                if (result.status === 'success') {
                    currentLorebookName = name;
                    document.getElementById('lorebook-selector').value = name;
                    await onLorebookSelected();
                }
            } catch (error) {
                showMessage('lorebook-message', 'Error creating lorebook: ' + error.message, 'error');
            }
        }
        
        async function exportCurrentLorebook() {
            if (!currentLorebookName) return;
            
            try {
                const response = await fetch(`/api/lorebooks/${encodeURIComponent(currentLorebookName)}/export`);
                const data = await response.json();
                
                const blob = new Blob([data.lorebook], {type: 'application/json'});
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${currentLorebookName}.json`;
                a.click();
                
                showMessage('lorebook-message', 'Lorebook exported successfully', 'success');
            } catch (error) {
                showMessage('lorebook-message', 'Error exporting lorebook: ' + error.message, 'error');
            }
        }
        
        async function deleteCurrentLorebook() {
            if (!currentLorebookName) return;
            
            if (!confirm(`Delete lorebook "${currentLorebookName}" and all its entries?`)) {
                return;
            }
            
            try {
                const response = await fetch(`/api/lorebooks/${encodeURIComponent(currentLorebookName)}`, {
                    method: 'DELETE'
                });
                
                const result = await response.json();
                showMessage('lorebook-message', result.message, result.status === 'success' ? 'success' : 'error');
                
                currentLorebookName = null;
                document.getElementById('lorebook-selector').value = '';
                document.getElementById('lorebook-info').style.display = 'none';
                loadLorebooksList();
                loadLorebookList();
            } catch (error) {
                showMessage('lorebook-message', 'Error deleting lorebook: ' + error.message, 'error');
            }
        }
        
        // Load config on page load
        window.onload = function() {
            loadConfig();
        };
    </script>
</body>
</html>
