<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Discord Bot Configuration</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 10px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
            overflow: hidden;
        }
        
        header {
            background: #2c3e50;
            color: white;
            padding: 30px;
            text-align: center;
        }
        
        h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }
        
        .subtitle {
            opacity: 0.9;
            font-size: 1.1em;
        }
        
        .tabs {
            display: flex;
            background: #34495e;
            overflow-x: auto;
        }
        
        .tab {
            padding: 15px 30px;
            color: white;
            cursor: pointer;
            border: none;
            background: transparent;
            font-size: 16px;
            transition: background 0.3s;
            white-space: nowrap;
        }
        
        .tab:hover {
            background: rgba(255, 255, 255, 0.1);
        }
        
        .tab.active {
            background: white;
            color: #2c3e50;
        }
        
        .tab-content {
            padding: 30px;
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }
        
        .form-group {
            margin-bottom: 20px;
        }
        
        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #2c3e50;
        }
        
        input[type="text"],
        input[type="number"],
        textarea,
        select {
            width: 100%;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 5px;
            font-size: 14px;
            transition: border-color 0.3s;
        }
        
        input[type="text"]:focus,
        input[type="number"]:focus,
        textarea:focus,
        select:focus {
            outline: none;
            border-color: #667eea;
        }
        
        textarea {
            resize: vertical;
            min-height: 100px;
            font-family: monospace;
        }
        
        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.3s;
            margin-right: 10px;
        }
        
        .btn-primary {
            background: #667eea;
            color: white;
        }
        
        .btn-primary:hover {
            background: #5568d3;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }
        
        .btn-secondary {
            background: #95a5a6;
            color: white;
        }
        
        .btn-secondary:hover {
            background: #7f8c8d;
        }
        
        .btn-danger {
            background: #e74c3c;
            color: white;
        }
        
        .btn-danger:hover {
            background: #c0392b;
        }
        
        .btn-success {
            background: #27ae60;
            color: white;
        }
        
        .btn-success:hover {
            background: #229954;
        }
        
        .list-item {
            padding: 15px;
            background: #f8f9fa;
            border-radius: 5px;
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .list-item:hover {
            background: #e9ecef;
        }
        
        .message {
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
            display: none;
        }
        
        .message.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        
        .message.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        
        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
        }
        
        .slider-container {
            margin-bottom: 15px;
        }
        
        .slider-value {
            display: inline-block;
            min-width: 60px;
            text-align: right;
            font-weight: bold;
            color: #667eea;
        }
        
        input[type="range"] {
            width: calc(100% - 70px);
            margin-left: 10px;
        }
        
        .import-export {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }
        
        .json-display {
            background: #2c3e50;
            color: #ecf0f1;
            padding: 15px;
            border-radius: 5px;
            font-family: monospace;
            font-size: 12px;
            overflow-x: auto;
            max-height: 400px;
            overflow-y: auto;
        }
        
        .btn-sm {
            padding: 6px 12px;
            font-size: 14px;
        }
        
        .item {
            padding: 15px;
            background: #f8f9fa;
            border-radius: 5px;
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
        }
        
        .item:hover {
            background: #e9ecef;
        }
        
        .prompt-section {
            background: #f8f9fa;
            border: 2px solid #ddd;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
            position: relative;
        }
        
        .prompt-section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .prompt-section-controls {
            display: flex;
            gap: 8px;
            align-items: center;
        }
        
        .prompt-section-role {
            padding: 8px 12px;
            border: 2px solid #ddd;
            border-radius: 5px;
            background: white;
            font-size: 14px;
            font-weight: 600;
        }
        
        .prompt-section textarea {
            width: 100%;
            min-height: 100px;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 5px;
            font-family: inherit;
            font-size: 14px;
            resize: vertical;
        }
        
        .prompt-section-order-btns {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }
        
        .btn-icon {
            padding: 4px 8px;
            font-size: 12px;
            line-height: 1;
            min-width: 30px;
        }
        
        .collapsible-header {
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px;
            background: #f8f9fa;
            border: 2px solid #ddd;
            border-radius: 5px;
            margin-bottom: 10px;
            transition: background 0.3s;
        }
        
        .collapsible-header:hover {
            background: #e9ecef;
        }
        
        .collapsible-header h3 {
            margin: 0;
            font-size: 1.2em;
        }
        
        .collapsible-icon {
            font-size: 1.2em;
            transition: transform 0.3s;
        }
        
        .collapsible-icon.open {
            transform: rotate(180deg);
        }
        
        .collapsible-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out;
        }
        
        .collapsible-content.open {
            max-height: 3000px;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>🤖 Discord Bot Configuration</h1>
            <p class="subtitle">Configure your Discord bot with OpenAI-compatible API, Presets, and Character Cards</p>
        </header>
        
        <div class="tabs">
            <button class="tab active" onclick="switchTab('config')">Configuration</button>
            <button class="tab" onclick="switchTab('presets')">Presets</button>
            <button class="tab" onclick="switchTab('characters')">Characters</button>
            <button class="tab" onclick="switchTab('user_characters')">User Characters</button>
            <button class="tab" onclick="switchTab('lorebook')">Lorebook</button>
            <button class="tab" onclick="switchTab('servers')">Servers/Channels</button>
        </div>
        
        <!-- Configuration Tab -->
        <div id="config" class="tab-content active">
            <div id="config-message" class="message"></div>
            <h2>Bot Configuration</h2>
            
            <div class="form-group">
                <label>Discord Bot Token</label>
                <input type="text" id="discord-token" placeholder="Your Discord bot token">
            </div>
            
            <h3>OpenAI API Configuration</h3>
            <div class="grid">
                <div class="form-group">
                    <label>API Key</label>
                    <input type="text" id="api-key" placeholder="Your API key">
                </div>
                
                <div class="form-group">
                    <label>Base URL</label>
                    <input type="text" id="base-url" placeholder="https://api.openai.com/v1">
                </div>
                
                <div class="form-group">
                    <label>Model</label>
                    <div style="display: flex; gap: 10px;">
                        <input type="text" id="model" list="model-list" placeholder="gpt-3.5-turbo" style="flex: 1;">
                        <datalist id="model-list"></datalist>
                        <button onclick="pullModels()" class="btn-secondary" style="white-space: nowrap;">Pull Models</button>
                    </div>
                    <div id="models-message" class="message" style="margin-top: 5px; display: none;"></div>
                </div>
            </div>
            
            <h3>Saved API Configurations</h3>
            <p style="color: #666; margin-bottom: 15px;">Save and manage multiple API configurations for quick switching between different proxies and models. The dropdown shows "Base URL - Model Name" (API keys are hidden for security).</p>
            
            <div class="grid">
                <div class="form-group">
                    <label>Configuration Name</label>
                    <input type="text" id="api-config-name" placeholder="e.g., OpenAI GPT-4, Local Ollama, etc.">
                </div>
                
                <div class="form-group">
                    <label>Saved Configurations</label>
                    <select id="saved-api-configs" onchange="loadSelectedApiConfig()">
                        <option value="">-- Select a configuration --</option>
                    </select>
                </div>
            </div>
            
            <div style="display: flex; gap: 10px; margin-bottom: 20px;">
                <button class="btn btn-primary" onclick="saveCurrentApiConfig()">Save API Config</button>
                <button class="btn btn-secondary" onclick="loadApiConfigFromDropdown()">Load Selected</button>
                <button class="btn btn-danger" onclick="deleteSelectedApiConfig()">Delete Selected</button>
            </div>
            
            <div id="api-configs-list" style="margin-bottom: 20px;">
                <!-- List of saved configurations will appear here -->
            </div>
            
            <div class="collapsible-header" onclick="toggleCollapsible('default-preset-content')">
                <h3>Default Preset</h3>
                <span class="collapsible-icon open">▼</span>
            </div>
            <div id="default-preset-content" class="collapsible-content open">
                <div class="form-group" style="margin-bottom: 15px;">
                    <label>Load from Saved Preset</label>
                    <select id="default-preset-dropdown" onchange="loadPresetToDefault()">
                        <option value="">-- Select a preset to load --</option>
                    </select>
                    <small style="color: #666; display: block; margin-top: 5px;">
                        Load any saved preset from the Presets tab into the Default Preset configuration below.
                    </small>
                </div>
                
                <div class="form-group">
                    <label>Prompt Sections</label>
                    <p style="color: #666; margin-bottom: 15px;">Build your default prompt with multiple sections. Each section can have a different role (System, User, or Assistant). Sections are processed in order from top to bottom.</p>
                    <div id="default-prompt-sections-container"></div>
                    <button type="button" class="btn btn-secondary" onclick="addDefaultPromptSection()" style="margin-top: 10px;">+ Add Section</button>
                </div>
                
                <div class="grid">
                    <div class="slider-container">
                        <label>Temperature: <span class="slider-value" id="temp-value">0.7</span></label>
                        <input type="range" id="temperature" min="0" max="2" step="0.01" value="0.7" oninput="updateSlider('temp', this.value)">
                    </div>
                    
                    <div class="slider-container">
                        <label>Max Tokens (Context): <span class="slider-value" id="tokens-value">2000</span></label>
                        <input type="range" id="max-tokens" min="100" max="200000" step="100" value="2000" oninput="updateSlider('tokens', this.value)">
                    </div>
                    
                    <div class="slider-container">
                        <label>Max Response Length: <span class="slider-value" id="response-length-value">2000</span></label>
                        <input type="range" id="max-response-length" min="100" max="16000" step="100" value="2000" oninput="updateSlider('response-length', this.value)">
                    </div>
                    
                    <div class="slider-container">
                        <label>Top P: <span class="slider-value" id="topp-value">1.0</span></label>
                        <input type="range" id="top-p" min="0" max="1" step="0.01" value="1.0" oninput="updateSlider('topp', this.value)">
                    </div>
                    
                    <div class="slider-container">
                        <label style="display: flex; align-items: center; gap: 10px;">
                            <input type="checkbox" id="frequency-penalty-enabled" style="width: auto;" checked>
                            <span>Frequency Penalty: <span class="slider-value" id="freq-value">0.0</span></span>
                        </label>
                        <input type="range" id="frequency-penalty" min="0" max="2" step="0.01" value="0.0" oninput="updateSlider('freq', this.value)">
                        <small style="color: #666; display: block; margin-top: 5px;">Enable to use frequency penalty (may not be supported by all models like Gemini)</small>
                    </div>
                    
                    <div class="slider-container">
                        <label style="display: flex; align-items: center; gap: 10px;">
                            <input type="checkbox" id="presence-penalty-enabled" style="width: auto;" checked>
                            <span>Presence Penalty: <span class="slider-value" id="pres-value">0.0</span></span>
                        </label>
                        <input type="range" id="presence-penalty" min="0" max="2" step="0.01" value="0.0" oninput="updateSlider('pres', this.value)">
                        <small style="color: #666; display: block; margin-top: 5px;">Enable to use presence penalty (may not be supported by all models like Gemini)</small>
                    </div>
                </div>
            </div>
            
            <h3>Thinking Filter</h3>
            <p style="color: #666; margin-bottom: 15px;">Filter out thinking/reasoning tags from responses before sending to Discord. The full response (with thinking tags) will still be logged to the console and stored in conversation history.</p>
            
            <div class="form-group">
                <label style="display: flex; align-items: center; gap: 10px;">
                    <input type="checkbox" id="thinking-filter-enabled" style="width: auto;">
                    <span>Enable Thinking Filter</span>
                </label>
            </div>
            
            <div class="grid">
                <div class="form-group">
                    <label>Start Thinking Tag</label>
                    <input type="text" id="thinking-start-tag" placeholder="<think>" value="<think>">
                    <small style="color: #666; display: block; margin-top: 5px;">Tag that marks the beginning of thinking content</small>
                </div>
                
                <div class="form-group">
                    <label>End Thinking Tag</label>
                    <input type="text" id="thinking-end-tag" placeholder="</think>" value="</think>">
                    <small style="color: #666; display: block; margin-top: 5px;">Tag that marks the end of thinking content</small>
                </div>
            </div>
            
            <div class="form-group">
                <label>Console Preview</label>
                <textarea id="console-preview" readonly style="background: #f5f5f5; font-family: monospace; min-height: 150px; resize: vertical;" placeholder="Full responses (with thinking tags) will be shown here and logged to the console when filtering is enabled..."></textarea>
                <small style="color: #666; display: block; margin-top: 5px;">
                    This preview shows the full response before filtering. When filtering is enabled, the bot will log both the full response and filtered response to the console.
                </small>
            </div>
            
            <h3>Auto Context Loading</h3>
            <p style="color: #666; margin-bottom: 15px;">Configure how many messages are automatically loaded from channel history when starting a new conversation. This provides context from previous messages even after bot restarts.</p>
            
            <div class="slider-container">
                <label>Auto Context Limit: <span class="slider-value" id="auto-context-value">50</span> messages</label>
                <input type="range" id="auto-context-limit" min="10" max="8000" step="10" value="50" oninput="updateSlider('auto-context', this.value)">
                <small style="color: #666; display: block; margin-top: 5px;">
                    Number of messages to automatically load from channel history. Higher values provide more context but take longer to load. Can also be set via Discord using !setcontext command.
                </small>
            </div>
            
            <!-- CP Tracking Section -->
            <h3 style="margin-top: 30px;">Creation Points (CP) Tracking</h3>
            <p style="color: #666; margin-bottom: 15px;">
                Track Creation Points awarded by the AI and count responses. The system will automatically append CP totals and count to each response.
            </p>
            
            <div class="form-group">
                <label>
                    <input type="checkbox" id="cp-tracking-enabled" style="width: auto; margin-right: 8px;">
                    Enable CP Tracking
                </label>
                <small style="color: #666; display: block; margin-top: 5px;">
                    When enabled, the AI will be reminded to note Creation Points awarded for achievements/actions, and the system will track CP totals and response counts.
                </small>
            </div>
            
            <div id="cp-tracking-settings" style="margin-left: 20px; display: none;">
                <div class="form-group">
                    <label>CP Per 10 Responses:</label>
                    <input type="number" id="cp-per-count" min="0" step="1" value="100">
                    <small style="color: #666; display: block; margin-top: 5px;">
                        Amount of CP to award automatically when the count reaches 10/10. Default: 100
                    </small>
                </div>
                
                <div class="form-group">
                    <label>Current CP Total:</label>
                    <div style="display: flex; gap: 10px; align-items: center;">
                        <input type="number" id="cp-total-display" min="0" step="1" value="0" style="flex: 1;">
                        <button class="btn btn-secondary" onclick="updateCPTotal()" style="white-space: nowrap;">Update CP Total</button>
                    </div>
                    <small style="color: #666; display: block; margin-top: 5px;">
                        Manually edit the current CP total. Changes will be applied to the next response.
                    </small>
                </div>
            </div>
            
            <button class="btn btn-primary" onclick="saveConfig()">Save Configuration</button>
            <button class="btn btn-secondary" onclick="loadConfig()">Reload</button>
        </div>
        
        <!-- Presets Tab -->
        <div id="presets" class="tab-content">
            <div id="presets-message" class="message"></div>
            <h2>Presets Management</h2>
            
            <div class="form-group">
                <label>Preset Name</label>
                <input type="text" id="preset-name" placeholder="Enter preset name">
            </div>
            
            <div class="form-group">
                <label>Prompt Sections</label>
                <p style="color: #666; margin-bottom: 15px;">Build your prompt with multiple sections. Each section can have a different role (System, User, or Assistant). Sections are processed in order from top to bottom.</p>
                <div id="prompt-sections-container"></div>
                <button type="button" class="btn btn-secondary" onclick="addPromptSection()" style="margin-top: 10px;">+ Add Section</button>
            </div>
            
            <div class="grid">
                <div class="slider-container">
                    <label>Temperature: <span class="slider-value" id="preset-temp-value">0.7</span></label>
                    <input type="range" id="preset-temperature" min="0" max="2" step="0.01" value="0.7" oninput="updateSlider('preset-temp', this.value)">
                </div>
                
                <div class="slider-container">
                    <label>Max Tokens (Context): <span class="slider-value" id="preset-tokens-value">2000</span></label>
                    <input type="range" id="preset-max-tokens" min="100" max="200000" step="100" value="2000" oninput="updateSlider('preset-tokens', this.value)">
                </div>
                
                <div class="slider-container">
                    <label>Max Response Length: <span class="slider-value" id="preset-response-length-value">2000</span></label>
                    <input type="range" id="preset-max-response-length" min="100" max="16000" step="100" value="2000" oninput="updateSlider('preset-response-length', this.value)">
                </div>
                
                <div class="slider-container">
                    <label>Top P: <span class="slider-value" id="preset-topp-value">1.0</span></label>
                    <input type="range" id="preset-top-p" min="0" max="1" step="0.01" value="1.0" oninput="updateSlider('preset-topp', this.value)">
                </div>
                
                <div class="slider-container">
                    <label style="display: flex; align-items: center; gap: 10px;">
                        <input type="checkbox" id="preset-frequency-penalty-enabled" style="width: auto;" checked>
                        <span>Frequency Penalty: <span class="slider-value" id="preset-freq-value">0.0</span></span>
                    </label>
                    <input type="range" id="preset-frequency-penalty" min="0" max="2" step="0.01" value="0.0" oninput="updateSlider('preset-freq', this.value)">
                    <small style="color: #666; display: block; margin-top: 5px;">Enable to use frequency penalty (may not be supported by all models like Gemini)</small>
                </div>
                
                <div class="slider-container">
                    <label style="display: flex; align-items: center; gap: 10px;">
                        <input type="checkbox" id="preset-presence-penalty-enabled" style="width: auto;" checked>
                        <span>Presence Penalty: <span class="slider-value" id="preset-pres-value">0.0</span></span>
                    </label>
                    <input type="range" id="preset-presence-penalty" min="0" max="2" step="0.01" value="0.0" oninput="updateSlider('preset-pres', this.value)">
                    <small style="color: #666; display: block; margin-top: 5px;">Enable to use presence penalty (may not be supported by all models like Gemini)</small>
                </div>
            </div>
            
            <h3 style="margin-top: 30px;">SillyTavern Options</h3>
            <p style="color: #666; margin-bottom: 15px;">Optional settings for SillyTavern-style character card integration and prompt formatting.</p>
            
            <div class="grid">
                <div class="form-group">
                    <label>Prompt Format</label>
                    <select id="preset-prompt-format">
                        <option value="default">Default</option>
                        <option value="sillytavern">SillyTavern</option>
                    </select>
                    <small style="color: #666; display: block; margin-top: 5px;">
                        Format style for building prompts. Use "SillyTavern" for proper role separation with character cards.
                    </small>
                </div>
                
                <div class="form-group">
                    <label>Character Position</label>
                    <select id="preset-character-position">
                        <option value="system">System Message</option>
                        <option value="examples">Example Dialogues</option>
                        <option value="both">Both</option>
                    </select>
                    <small style="color: #666; display: block; margin-top: 5px;">
                        Where to inject character card information in the message structure.
                    </small>
                </div>
            </div>
            
            <div class="grid">
                <div class="form-group">
                    <label style="display: flex; align-items: center; gap: 10px;">
                        <input type="checkbox" id="preset-include-examples" checked style="width: auto;">
                        Include Example Dialogues
                    </label>
                    <small style="color: #666; display: block; margin-top: 5px;">
                        Whether to include example dialogues from character cards (first_mes and mes_example fields).
                    </small>
                </div>
                
                <div class="form-group">
                    <label>Example Separator</label>
                    <input type="text" id="preset-example-separator" value="<START>" placeholder="<START>">
                    <small style="color: #666; display: block; margin-top: 5px;">
                        The separator used in mes_example field of character cards to split dialogue examples.
                    </small>
                </div>
            </div>
            
            <button class="btn btn-primary" onclick="savePreset()">Save Preset</button>
            <button class="btn btn-secondary" onclick="loadPreset()">Load Preset</button>
            <button class="btn btn-success" onclick="exportPreset()">Export</button>
            <button class="btn btn-secondary" onclick="showImportPreset()">Import</button>
            
            <div id="import-preset-section" style="display: none; margin-top: 20px;">
                <div class="form-group">
                    <label>Import Preset (JSON)</label>
                    <textarea id="import-preset-json" placeholder='{"temperature": 0.7, ...}'></textarea>
                </div>
                <button class="btn btn-success" onclick="importPreset()">Import</button>
                <button class="btn btn-secondary" onclick="cancelImportPreset()">Cancel</button>
            </div>
            
            <h3 style="margin-top: 30px;">Available Presets</h3>
            <div id="presets-list"></div>
        </div>
        
        <!-- Characters Tab -->
        <div id="characters" class="tab-content">
            <div id="characters-message" class="message"></div>
            <h2>Character Cards Management</h2>
            
            <div class="form-group">
                <label>Character Name</label>
                <input type="text" id="character-name" placeholder="Enter character name">
            </div>
            
            <div class="grid">
                <div class="form-group">
                    <label>Display Name</label>
                    <input type="text" id="character-display-name" placeholder="Character's display name">
                </div>
                
                <div class="form-group">
                    <label>Personality</label>
                    <input type="text" id="character-personality" placeholder="Friendly, helpful, creative...">
                </div>
            </div>
            
            <div class="form-group">
                <label>Description</label>
                <textarea id="character-description" placeholder="Describe the character..."></textarea>
            </div>
            
            <div class="form-group">
                <label>Scenario</label>
                <textarea id="character-scenario" placeholder="The scenario or context for interactions..."></textarea>
            </div>
            
            <div class="form-group">
                <label>System Prompt (Optional - overrides description-based prompt)</label>
                <textarea id="character-system-prompt" placeholder="Custom system prompt..."></textarea>
            </div>
            
            <div class="form-group">
                <label>Avatar (Optional - bot's profile picture will change to this image)</label>
                <div style="margin-bottom: 10px;">
                    <label style="font-weight: normal; display: block; margin-bottom: 5px;">
                        <input type="radio" name="avatar-method" value="url" checked onchange="toggleAvatarMethod()"> Use Image URL
                    </label>
                    <input type="text" id="character-avatar-url" placeholder="https://example.com/avatar.png" style="margin-left: 20px;">
                </div>
                <div>
                    <label style="font-weight: normal; display: block; margin-bottom: 5px;">
                        <input type="radio" name="avatar-method" value="upload" onchange="toggleAvatarMethod()"> Upload Image File
                    </label>
                    <input type="file" id="character-avatar-file" accept="image/png,image/jpeg,image/gif" style="margin-left: 20px; display: none;">
                    <div id="avatar-preview" style="margin-left: 20px; margin-top: 10px; display: none;">
                        <img id="avatar-preview-img" style="max-width: 100px; max-height: 100px; border-radius: 5px; border: 2px solid #ddd;">
                        <button type="button" class="btn btn-secondary" onclick="clearAvatarUpload()" style="margin-left: 10px; padding: 5px 10px; font-size: 12px;">Clear</button>
                    </div>
                </div>
                <small style="display: block; margin-top: 10px; color: #666;">Choose to enter an image URL or upload an image file (PNG, JPG, GIF). The bot's avatar will update when this character is loaded.</small>
            </div>
            
            <button class="btn btn-primary" onclick="saveCharacter()">Save Character</button>
            <button class="btn btn-secondary" onclick="loadCharacter()">Load Character</button>
            <button class="btn btn-success" onclick="exportCharacter()">Export</button>
            <button class="btn btn-secondary" onclick="showImportCharacter()">Import</button>
            
            <div id="import-character-section" style="display: none; margin-top: 20px;">
                <div class="form-group">
                    <label>Import Character (JSON)</label>
                    <textarea id="import-character-json" placeholder='{"name": "...", "description": "..."}'></textarea>
                </div>
                <button class="btn btn-success" onclick="importCharacter()">Import</button>
                <button class="btn btn-secondary" onclick="cancelImportCharacter()">Cancel</button>
            </div>
            
            <h3 style="margin-top: 30px;">Available Characters</h3>
            <div id="characters-list"></div>
        </div>
        
        <!-- User Characters Tab -->
        <div id="user_characters" class="tab-content">
            <div id="user-characters-message" class="message"></div>
            <h2>Saved Character Information</h2>
            <p style="margin-bottom: 20px; color: #666;">Save descriptions for user characters that will be used in roleplay. The AI will use these descriptions for context when those character names are mentioned.</p>
            
            <div class="form-group">
                <label>Character Name</label>
                <input type="text" id="user-character-name" placeholder="Enter character name (e.g., Alice, Bob)">
            </div>
            
            <div class="form-group">
                <label>Description (Physical appearance and traits)</label>
                <textarea id="user-character-description" placeholder="A brave warrior with long red hair, green eyes, wearing silver armor. Known for her courage and compassion..." rows="5"></textarea>
            </div>
            
            <div class="form-group">
                <label>
                    <input type="checkbox" id="user-character-sheet-enabled"> 
                    Enable Character Sheet
                </label>
                <p style="font-size: 0.9em; color: #666; margin: 5px 0;">When enabled, the character sheet will be sent to the AI along with the description.</p>
            </div>
            
            <div class="form-group">
                <label>Character Sheet (Abilities and Perks)</label>
                <textarea id="user-character-sheet" placeholder="Abilities: Flight, Super Strength&#10;Perks: Enhanced Reflexes, Night Vision&#10;Special Powers: Energy Manipulation" rows="5"></textarea>
                <p style="font-size: 0.9em; color: #666; margin: 5px 0;">List any unusual abilities or perks this character has. This will be included in a [sheet][/sheet] block when enabled.</p>
            </div>
            
            <button class="btn btn-primary" onclick="saveUserCharacter()">Save User Character</button>
            <button class="btn btn-secondary" onclick="loadUserCharacter()">Load User Character</button>
            <button class="btn btn-success" onclick="exportUserCharacters()">Export All</button>
            <button class="btn btn-secondary" onclick="showImportUserCharacters()">Import</button>
            
            <div id="import-user-characters-section" style="display: none; margin-top: 20px;">
                <div class="form-group">
                    <label>Import User Characters (JSON)</label>
                    <textarea id="import-user-characters-json" placeholder='{"Alice": {"name": "Alice", "description": "..."}, ...}'></textarea>
                </div>
                <button class="btn btn-success" onclick="importUserCharacters()">Import</button>
                <button class="btn btn-secondary" onclick="cancelImportUserCharacters()">Cancel</button>
            </div>
            
            <h3 style="margin-top: 30px;">Saved User Characters</h3>
            <div id="user-characters-list"></div>
        </div>
        
        <!-- Lorebook Tab -->
        <div id="lorebook" class="tab-content">
            <div id="lorebook-message" class="message"></div>
            <h2>Lorebook - World Information</h2>
            <p style="margin-bottom: 20px; color: #666;">Add world-building and lore information that the AI can use for context. Entries can be triggered by keywords or set to always be active.</p>
            
            <!-- Lorebook Management Section -->
            <div style="background: #f5f5f5; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                <h3 style="margin-top: 0;">Manage Lorebooks</h3>
                <div style="display: flex; gap: 10px; margin-bottom: 15px; align-items: center;">
                    <div class="form-group" style="flex: 1; margin: 0;">
                        <label>Active Lorebook</label>
                        <select id="lorebook-selector" onchange="onLorebookSelected()">
                            <option value="">Loading...</option>
                        </select>
                    </div>
                    <button class="btn btn-primary" onclick="showCreateLorebookDialog()" style="margin-top: 24px;">New Lorebook</button>
                </div>
                
                <div id="lorebook-info" style="display: none; margin-bottom: 15px;">
                    <div style="display: flex; gap: 10px; align-items: center; margin-bottom: 10px;">
                        <span style="font-weight: bold;" id="current-lorebook-name"></span>
                        <span style="color: #666;" id="current-lorebook-description"></span>
                        <span style="color: #888; font-style: italic;" id="current-lorebook-character"></span>
                        <label style="margin-left: auto; display: flex; align-items: center; gap: 5px;">
                            <input type="checkbox" id="lorebook-enabled" onchange="toggleCurrentLorebook()" style="width: auto; margin: 0;">
                            <span>Enabled</span>
                        </label>
                    </div>
                    <div style="display: flex; gap: 10px;">
                        <button class="btn btn-secondary btn-sm" onclick="exportCurrentLorebook()">Export This Lorebook</button>
                        <button class="btn btn-secondary btn-sm" onclick="showEditLorebookDialog()">Edit Metadata</button>
                        <button class="btn btn-danger btn-sm" onclick="deleteCurrentLorebook()">Delete This Lorebook</button>
                    </div>
                </div>
                
                <!-- Edit Lorebook Metadata Dialog -->
                <div id="edit-lorebook-dialog" style="display: none; background: #fff; padding: 20px; border-radius: 8px; border: 2px solid #007bff; margin-bottom: 20px;">
                    <h3>Edit Lorebook Metadata</h3>
                    <div class="form-group">
                        <label>Description</label>
                        <input type="text" id="edit-lorebook-description" placeholder="Brief description of this lorebook">
                    </div>
                    <div class="form-group">
                        <label>Link to Characters</label>
                        <div style="display: flex; gap: 10px; align-items: flex-start;">
                            <select id="edit-lorebook-character-selector" style="flex: 1;">
                                <option value="">Select a character to add...</option>
                            </select>
                            <button class="btn btn-sm btn-primary" onclick="addCharacterToEditLorebook()" style="white-space: nowrap;">+ Add</button>
                        </div>
                        <div id="edit-lorebook-linked-characters" style="margin-top: 10px; padding: 10px; border: 1px solid #ddd; border-radius: 5px; min-height: 50px; background: #f9f9f9;">
                            <div style="color: #666; font-style: italic;">No characters linked (Global lorebook)</div>
                        </div>
                        <small style="color: #666; display: block; margin-top: 5px;">
                            If linked to characters, this lorebook will only be active when any of those characters are loaded.
                            Global lorebooks (no characters linked) are always active when enabled.
                        </small>
                    </div>
                    <button class="btn btn-primary" onclick="saveLorebookMetadata()">Save</button>
                    <button class="btn btn-secondary" onclick="cancelEditLorebook()">Cancel</button>
                </div>
                
                <div style="margin-top: 15px;">
                    <h4 style="margin: 10px 0;">All Lorebooks</h4>
                    <div id="lorebooks-list" style="max-height: 200px; overflow-y: auto;"></div>
                </div>
            </div>
            
            <!-- Create Lorebook Dialog -->
            <div id="create-lorebook-dialog" style="display: none; background: #fff; padding: 20px; border-radius: 8px; border: 2px solid #007bff; margin-bottom: 20px;">
                <h3>Create New Lorebook</h3>
                <div class="form-group">
                    <label>Lorebook Name</label>
                    <input type="text" id="new-lorebook-name" placeholder="e.g., Fantasy World, Sci-Fi Setting">
                </div>
                <div class="form-group">
                    <label>Description (optional)</label>
                    <input type="text" id="new-lorebook-description" placeholder="Brief description of this lorebook">
                </div>
                <div class="form-group">
                    <label>Link to Characters (optional)</label>
                    <div style="display: flex; gap: 10px; align-items: flex-start;">
                        <select id="new-lorebook-character-selector" style="flex: 1;">
                            <option value="">Select a character to add...</option>
                        </select>
                        <button class="btn btn-sm btn-primary" onclick="addCharacterToNewLorebook()" style="white-space: nowrap;">+ Add</button>
                    </div>
                    <div id="new-lorebook-linked-characters" style="margin-top: 10px; padding: 10px; border: 1px solid #ddd; border-radius: 5px; min-height: 50px; background: #f9f9f9;">
                        <div style="color: #666; font-style: italic;">No characters linked (Global lorebook)</div>
                    </div>
                    <small style="color: #666; display: block; margin-top: 5px;">
                        If linked to characters, this lorebook will only be active when any of those characters are loaded.
                        Global lorebooks (no characters linked) are always active when enabled.
                    </small>
                </div>
                <button class="btn btn-primary" onclick="createLorebook()">Create</button>
                <button class="btn btn-secondary" onclick="cancelCreateLorebook()">Cancel</button>
            </div>
            
            <h3>Add/Edit Entry</h3>
            <div class="form-group">
                <label>Entry Key (Unique identifier)</label>
                <input type="text" id="lorebook-key" placeholder="e.g., Kingdom of Aldoria, Magic System, Character Background">
            </div>
            
            <div class="form-group">
                <label>Content (Lore information)</label>
                <textarea id="lorebook-content" placeholder="Describe the lore, world details, or information..." rows="6"></textarea>
            </div>
            
            <div class="form-group">
                <label>Keywords (comma-separated, optional)</label>
                <input type="text" id="lorebook-keywords" placeholder="e.g., kingdom, aldoria, magic">
                <small style="color: #666; display: block; margin-top: 5px;">Entry will appear when any keyword is mentioned in conversation</small>
            </div>
            
            <div class="form-group">
                <label>Activation Type</label>
                <select id="lorebook-activation-type" style="width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 5px; font-size: 14px;">
                    <option value="normal">Normal (Keyword-triggered)</option>
                    <option value="constant">Constant (Always active)</option>
                    <option value="vectorized">Vectorized (Semantic search - future)</option>
                </select>
                <small style="color: #666; display: block; margin-top: 5px;">
                    <strong>Normal:</strong> Entry appears when keywords are mentioned<br>
                    <strong>Constant:</strong> Entry is always included in conversations<br>
                    <strong>Vectorized:</strong> Entry uses semantic search (planned feature, currently works like Normal)
                </small>
            </div>
            
            <button class="btn btn-primary" onclick="saveLorebookEntry()">Save Entry</button>
            <button class="btn btn-secondary" onclick="clearLorebookForm()">Clear Form</button>
            <button class="btn btn-success" onclick="exportLorebook()">Export All</button>
            <button class="btn btn-secondary" onclick="showImportLorebook()">Import</button>
            
            <div id="import-lorebook-section" style="display: none; margin-top: 20px;">
                <div class="form-group">
                    <label>Import Lorebook (JSON)</label>
                    <textarea id="import-lorebook-json" placeholder='{"Entry Key": {"key": "...", "content": "...", "keywords": [], "activation_type": "normal"}, ...}'></textarea>
                </div>
                <div class="form-group">
                    <label style="display: flex; align-items: center; gap: 8px;">
                        <input type="checkbox" id="lorebook-merge" checked style="width: auto; margin: 0;">
                        <span>Merge with existing entries (uncheck to replace all)</span>
                    </label>
                </div>
                <button class="btn btn-success" onclick="importLorebook()">Import</button>
                <button class="btn btn-secondary" onclick="cancelImportLorebook()">Cancel</button>
            </div>
            
            <h3 style="margin-top: 30px;">Lorebook Entries</h3>
            <div id="lorebook-list"></div>
        </div>
        
        <!-- Servers/Channels Tab -->
        <div id="servers" class="tab-content">
            <div id="servers-message" class="message"></div>
            <h2>Server Configuration</h2>
            <p style="margin-bottom: 20px; color: #666;">Configure presets, API configs, and characters for each server the bot is active in. These settings apply to all channels in the server. Channel-specific configurations set via Discord commands (!preset, !character) will override server settings.</p>
            
            <!-- Default Configuration Section -->
            <div style="background: #e8f4f8; border: 2px solid #3498db; border-radius: 8px; padding: 20px; margin-bottom: 25px;">
                <h3 style="margin-top: 0; color: #2c3e50; display: flex; align-items: center;">
                    <span style="font-size: 1.5em; margin-right: 10px;">⚙️</span>
                    Default Configuration
                </h3>
                <p style="color: #555; margin-bottom: 15px;">
                    These are the default settings used when a channel doesn't have specific configuration. 
                    These values come from the <strong>Configuration</strong> tab and update automatically when you save changes there.
                </p>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                    <div>
                        <label style="display: block; margin-bottom: 8px; font-weight: 600; color: #2c3e50;">Default Preset</label>
                        <div id="default-preset-display" style="padding: 10px; background: white; border: 2px solid #ddd; border-radius: 5px; color: #555;">
                            Loading...
                        </div>
                        <small style="color: #666; display: block; margin-top: 5px;">From Configuration → Default Preset</small>
                    </div>
                    <div>
                        <label style="display: block; margin-bottom: 8px; font-weight: 600; color: #2c3e50;">Default API Config</label>
                        <div id="default-api-display" style="padding: 10px; background: white; border: 2px solid #ddd; border-radius: 5px; color: #555;">
                            Loading...
                        </div>
                        <small style="color: #666; display: block; margin-top: 5px;">From Configuration → OpenAI API Configuration</small>
                    </div>
                </div>
            </div>
            
            <button class="btn btn-primary" onclick="loadServersList()" style="margin-bottom: 20px;">🔄 Refresh Servers</button>
            
            <div id="servers-list"></div>
        </div>
    </div>
    
    <script>
        // Tab switching
        function switchTab(tabName) {
            const tabs = document.querySelectorAll('.tab');
            const contents = document.querySelectorAll('.tab-content');
            
            tabs.forEach(tab => tab.classList.remove('active'));
            contents.forEach(content => content.classList.remove('active'));
            
            event.target.classList.add('active');
            document.getElementById(tabName).classList.add('active');
            
            if (tabName === 'presets') {
                loadPresetsList();
            } else if (tabName === 'characters') {
                loadCharactersList();
            } else if (tabName === 'user_characters') {
                loadUserCharactersList();
            } else if (tabName === 'lorebook') {
                loadLorebookList();
            } else if (tabName === 'servers') {
                loadServersList();
            }
        }
        
        // Slider updates
        function updateSlider(name, value) {
            document.getElementById(name + '-value').textContent = value;
        }
        
        // Avatar upload helper functions
        function toggleAvatarMethod() {
            const method = document.querySelector('input[name="avatar-method"]:checked').value;
            const urlInput = document.getElementById('character-avatar-url');
            const fileInput = document.getElementById('character-avatar-file');
            const preview = document.getElementById('avatar-preview');
            
            if (method === 'url') {
                urlInput.style.display = 'block';
                fileInput.style.display = 'none';
                preview.style.display = 'none';
            } else {
                urlInput.style.display = 'none';
                fileInput.style.display = 'block';
                preview.style.display = 'none';
            }
        }
        
        // CP Tracking functions
        function toggleCPTracking() {
            const enabled = document.getElementById('cp-tracking-enabled').checked;
            const settings = document.getElementById('cp-tracking-settings');
            settings.style.display = enabled ? 'block' : 'none';
        }
        
        async function updateCPTotal() {
            try {
                const cpTotal = parseInt(document.getElementById('cp-total-display').value) || 0;
                
                const response = await fetch('/api/cp_total', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({ cp_total: cpTotal })
                });
                
                const result = await response.json();
                showMessage('config-message', result.message || 'CP Total updated', result.status === 'success' ? 'success' : 'error');
            } catch (error) {
                showMessage('config-message', 'Error updating CP Total: ' + error.message, 'error');
            }
        }
        
        function clearAvatarUpload() {
            document.getElementById('character-avatar-file').value = '';
            document.getElementById('avatar-preview').style.display = 'none';
        }
        
        // File input change handler for preview
        document.addEventListener('DOMContentLoaded', function() {
            const fileInput = document.getElementById('character-avatar-file');
            if (fileInput) {
                fileInput.addEventListener('change', function(e) {
                    const file = e.target.files[0];
                    if (file) {
                        const reader = new FileReader();
                        reader.onload = function(e) {
                            const preview = document.getElementById('avatar-preview');
                            const img = document.getElementById('avatar-preview-img');
                            img.src = e.target.result;
                            preview.style.display = 'block';
                        };
                        reader.readAsDataURL(file);
                    }
                });
            }
            
            // CP Tracking toggle listener
            const cpTrackingCheckbox = document.getElementById('cp-tracking-enabled');
            if (cpTrackingCheckbox) {
                cpTrackingCheckbox.addEventListener('change', toggleCPTracking);
            }
        });
        
        // Show messages
        function showMessage(elementId, message, type) {
            const msgEl = document.getElementById(elementId);
            msgEl.textContent = message;
            msgEl.className = 'message ' + type;
            msgEl.style.display = 'block';
            setTimeout(() => {
                msgEl.style.display = 'none';
            }, 5000);
        }
        
        // Configuration functions
        async function loadConfig() {
            try {
                const response = await fetch('/api/config');
                const config = await response.json();
                
                document.getElementById('discord-token').value = config.discord_token || '';
                document.getElementById('api-key').value = config.openai_config?.api_key || '';
                document.getElementById('base-url').value = config.openai_config?.base_url || '';
                document.getElementById('model').value = config.openai_config?.model || '';
                
                const preset = config.default_preset || {};
                
                // Load default preset sections (backward compatible with system_prompt)
                if (preset.prompt_sections && preset.prompt_sections.length > 0) {
                    loadDefaultPromptSections(preset.prompt_sections);
                } else if (preset.system_prompt) {
                    // Convert old system_prompt to sections format
                    loadDefaultPromptSections([{
                        role: 'system',
                        content: preset.system_prompt,
                        order: 0,
                        enabled: true
                    }]);
                } else {
                    loadDefaultPromptSections([]);
                }
                
                document.getElementById('temperature').value = preset.temperature || 0.7;
                document.getElementById('max-tokens').value = preset.max_tokens || 2000;
                document.getElementById('max-response-length').value = preset.max_response_length || 2000;
                document.getElementById('top-p').value = preset.top_p || 1.0;
                document.getElementById('frequency-penalty').value = preset.frequency_penalty || 0.0;
                document.getElementById('presence-penalty').value = preset.presence_penalty || 0.0;
                document.getElementById('frequency-penalty-enabled').checked = preset.frequency_penalty_enabled !== false;
                document.getElementById('presence-penalty-enabled').checked = preset.presence_penalty_enabled !== false;
                
                updateSlider('temp', preset.temperature || 0.7);
                updateSlider('tokens', preset.max_tokens || 2000);
                updateSlider('response-length', preset.max_response_length || 2000);
                updateSlider('topp', preset.top_p || 1.0);
                updateSlider('freq', preset.frequency_penalty || 0.0);
                updateSlider('pres', preset.presence_penalty || 0.0);
                
                // Load thinking filter settings
                const thinkingFilter = config.thinking_filter || {};
                document.getElementById('thinking-filter-enabled').checked = thinkingFilter.enabled || false;
                document.getElementById('thinking-start-tag').value = thinkingFilter.start_tag || '<think>';
                document.getElementById('thinking-end-tag').value = thinkingFilter.end_tag || '</think>';
                
                // Load auto context limit
                const autoContextLimit = config.auto_context_limit || 50;
                document.getElementById('auto-context-limit').value = autoContextLimit;
                updateSlider('auto-context', autoContextLimit);
                
                // Load CP tracking settings
                const cpTracking = config.cp_tracking || {};
                document.getElementById('cp-tracking-enabled').checked = cpTracking.enabled || false;
                document.getElementById('cp-per-count').value = cpTracking.cp_per_count || 100;
                document.getElementById('cp-total-display').value = cpTracking.cp_total || 0;
                toggleCPTracking();
                
                showMessage('config-message', 'Configuration loaded', 'success');
            } catch (error) {
                showMessage('config-message', 'Error loading configuration: ' + error.message, 'error');
            }
        }
        
        async function saveConfig() {
            try {
                const defaultPresetSections = getDefaultPromptSections();
                
                const config = {
                    discord_token: document.getElementById('discord-token').value,
                    openai_config: {
                        api_key: document.getElementById('api-key').value,
                        base_url: document.getElementById('base-url').value,
                        model: document.getElementById('model').value
                    },
                    thinking_filter: {
                        enabled: document.getElementById('thinking-filter-enabled').checked,
                        start_tag: document.getElementById('thinking-start-tag').value,
                        end_tag: document.getElementById('thinking-end-tag').value
                    },
                    auto_context_limit: parseInt(document.getElementById('auto-context-limit').value),
                    cp_tracking: {
                        enabled: document.getElementById('cp-tracking-enabled').checked,
                        cp_per_count: parseInt(document.getElementById('cp-per-count').value) || 100,
                        cp_total: parseInt(document.getElementById('cp-total-display').value) || 0
                    },
                    default_preset: {
                        prompt_sections: defaultPresetSections,
                        temperature: parseFloat(document.getElementById('temperature').value),
                        max_tokens: parseInt(document.getElementById('max-tokens').value),
                        max_response_length: parseInt(document.getElementById('max-response-length').value),
                        top_p: parseFloat(document.getElementById('top-p').value),
                        frequency_penalty: parseFloat(document.getElementById('frequency-penalty').value),
                        presence_penalty: parseFloat(document.getElementById('presence-penalty').value),
                        frequency_penalty_enabled: document.getElementById('frequency-penalty-enabled').checked,
                        presence_penalty_enabled: document.getElementById('presence-penalty-enabled').checked
                    }
                };
                
                const response = await fetch('/api/config', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify(config)
                });
                
                const result = await response.json();
                showMessage('config-message', result.message, result.status === 'success' ? 'success' : 'error');
                
                // Update the default config display on Servers/Channels tab if it's loaded
                if (document.getElementById('default-preset-display')) {
                    await loadDefaultConfig();
                }
            } catch (error) {
                showMessage('config-message', 'Error saving configuration: ' + error.message, 'error');
            }
        }
        
        async function pullModels() {
            try {
                const apiKey = document.getElementById('api-key').value;
                const baseUrl = document.getElementById('base-url').value;
                
                if (!apiKey || !baseUrl) {
                    showMessage('models-message', 'Please enter API key and Base URL first', 'error');
                    return;
                }
                
                showMessage('models-message', 'Fetching models...', 'success');
                
                const response = await fetch('/api/models', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        api_key: apiKey,
                        base_url: baseUrl
                    })
                });
                
                const result = await response.json();
                
                if (result.status === 'success') {
                    const modelList = document.getElementById('model-list');
                    modelList.innerHTML = '';
                    
                    result.models.forEach(model => {
                        const option = document.createElement('option');
                        option.value = model;
                        modelList.appendChild(option);
                    });
                    
                    showMessage('models-message', `Found ${result.models.length} models`, 'success');
                } else {
                    showMessage('models-message', result.message, 'error');
                }
            } catch (error) {
                showMessage('models-message', 'Error fetching models: ' + error.message, 'error');
            }
        }
        
        // API Configuration Management Functions
        async function loadSavedApiConfigs() {
            try {
                const response = await fetch('/api/api_configs');
                const data = await response.json();
                const configs = data.configs || [];
                
                const select = document.getElementById('saved-api-configs');
                select.innerHTML = '<option value="">-- Select a configuration --</option>';
                
                const listDiv = document.getElementById('api-configs-list');
                listDiv.innerHTML = '<h4 style="margin-top: 20px;">Available API Configurations:</h4>';
                
                if (configs.length === 0) {
                    listDiv.innerHTML += '<p style="color: #666;">No saved API configurations yet.</p>';
                    return;
                }
                
                configs.forEach(config => {
                    const option = document.createElement('option');
                    option.value = config.name;
                    option.textContent = `${config.base_url} - ${config.model}`;
                    select.appendChild(option);
                    
                    const itemDiv = document.createElement('div');
                    itemDiv.className = 'list-item';
                    itemDiv.innerHTML = `
                        <div>
                            <strong>${config.name}</strong>
                            <div style="color: #666; font-size: 0.9em;">${config.base_url} - ${config.model}</div>
                        </div>
                        <div>
                            <button class="btn btn-sm btn-secondary" onclick="loadApiConfigByName('${config.name}')">Load</button>
                            <button class="btn btn-sm btn-danger" onclick="deleteApiConfigByName('${config.name}')">Delete</button>
                        </div>
                    `;
                    listDiv.appendChild(itemDiv);
                });
            } catch (error) {
                console.error('Error loading saved API configs:', error);
            }
        }
        
        async function saveCurrentApiConfig() {
            const name = document.getElementById('api-config-name').value.trim();
            const apiKey = document.getElementById('api-key').value;
            const baseUrl = document.getElementById('base-url').value;
            const model = document.getElementById('model').value;
            
            if (!name) {
                showMessage('config-message', 'Please enter a configuration name', 'error');
                return;
            }
            
            if (!apiKey || !baseUrl || !model) {
                showMessage('config-message', 'Please fill in all API configuration fields (API Key, Base URL, Model)', 'error');
                return;
            }
            
            try {
                const response = await fetch(`/api/api_configs/${encodeURIComponent(name)}`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        api_key: apiKey,
                        base_url: baseUrl,
                        model: model
                    })
                });
                
                const result = await response.json();
                showMessage('config-message', result.message, result.status === 'success' ? 'success' : 'error');
                
                if (result.status === 'success') {
                    document.getElementById('api-config-name').value = '';
                    await loadSavedApiConfigs();
                }
            } catch (error) {
                showMessage('config-message', 'Error saving API configuration: ' + error.message, 'error');
            }
        }
        
        async function loadApiConfigByName(name) {
            try {
                const response = await fetch(`/api/api_configs/${encodeURIComponent(name)}/load`, {
                    method: 'POST'
                });
                
                const result = await response.json();
                
                if (result.status === 'success') {
                    const config = result.config;
                    document.getElementById('api-key').value = config.api_key;
                    document.getElementById('base-url').value = config.base_url;
                    document.getElementById('model').value = config.model;
                    document.getElementById('api-config-name').value = name;
                    
                    showMessage('config-message', `Loaded API configuration: ${name}`, 'success');
                } else {
                    showMessage('config-message', result.message, 'error');
                }
            } catch (error) {
                showMessage('config-message', 'Error loading API configuration: ' + error.message, 'error');
            }
        }
        
        async function loadApiConfigFromDropdown() {
            const select = document.getElementById('saved-api-configs');
            const name = select.value;
            
            if (!name) {
                showMessage('config-message', 'Please select a configuration to load', 'error');
                return;
            }
            
            await loadApiConfigByName(name);
        }
        
        async function loadSelectedApiConfig() {
            // Auto-load when selection changes
            const select = document.getElementById('saved-api-configs');
            if (select.value) {
                const selectedText = select.options[select.selectedIndex].text;
                document.getElementById('api-config-name').value = select.value;
                // Just update the name field, don't auto-load the full config
                // User needs to click "Load Selected" button
            }
        }
        
        async function deleteApiConfigByName(name) {
            if (!confirm(`Delete API configuration "${name}"?`)) {
                return;
            }
            
            try {
                const response = await fetch(`/api/api_configs/${encodeURIComponent(name)}`, {
                    method: 'DELETE'
                });
                
                const result = await response.json();
                showMessage('config-message', result.message, result.status === 'success' ? 'success' : 'error');
                
                if (result.status === 'success') {
                    await loadSavedApiConfigs();
                    
                    // Clear name field if it was the deleted config
                    if (document.getElementById('api-config-name').value === name) {
                        document.getElementById('api-config-name').value = '';
                    }
                }
            } catch (error) {
                showMessage('config-message', 'Error deleting API configuration: ' + error.message, 'error');
            }
        }
        
        async function deleteSelectedApiConfig() {
            const select = document.getElementById('saved-api-configs');
            const name = select.value;
            
            if (!name) {
                showMessage('config-message', 'Please select a configuration to delete', 'error');
                return;
            }
            
            await deleteApiConfigByName(name);
        }
        
        // Preset functions
        async function loadPresetsList() {
            try {
                const response = await fetch('/api/presets');
                const data = await response.json();
                
                const listEl = document.getElementById('presets-list');
                listEl.innerHTML = '';
                
                if (data.presets.length === 0) {
                    listEl.innerHTML = '<p>No presets available</p>';
                    return;
                }
                
                data.presets.forEach(preset => {
                    const item = document.createElement('div');
                    item.className = 'list-item';
                    item.innerHTML = `
                        <span>${preset}</span>
                        <div>
                            <button class="btn btn-secondary" onclick="selectPreset('${preset}')">Load</button>
                            <button class="btn btn-danger" onclick="deletePreset('${preset}')">Delete</button>
                        </div>
                    `;
                    listEl.appendChild(item);
                });
            } catch (error) {
                console.error('Error loading presets:', error);
            }
        }
        
        async function selectPreset(name) {
            try {
                const response = await fetch(`/api/presets/${name}`);
                const preset = await response.json();
                
                document.getElementById('preset-name').value = name;
                
                // Load prompt sections (backward compatible with system_prompt)
                if (preset.prompt_sections && preset.prompt_sections.length > 0) {
                    loadPromptSections(preset.prompt_sections);
                } else if (preset.system_prompt) {
                    // Convert old system_prompt to sections format
                    loadPromptSections([{
                        role: 'system',
                        content: preset.system_prompt,
                        order: 0,
                        enabled: true
                    }]);
                } else {
                    loadPromptSections([]);
                }
                
                document.getElementById('preset-temperature').value = preset.temperature || 0.7;
                document.getElementById('preset-max-tokens').value = preset.max_tokens || 2000;
                document.getElementById('preset-max-response-length').value = preset.max_response_length || 2000;
                document.getElementById('preset-top-p').value = preset.top_p || 1.0;
                document.getElementById('preset-frequency-penalty').value = preset.frequency_penalty || 0.0;
                document.getElementById('preset-presence-penalty').value = preset.presence_penalty || 0.0;
                document.getElementById('preset-frequency-penalty-enabled').checked = preset.frequency_penalty_enabled !== false;
                document.getElementById('preset-presence-penalty-enabled').checked = preset.presence_penalty_enabled !== false;
                document.getElementById('preset-prompt-format').value = preset.prompt_format || 'default';
                document.getElementById('preset-character-position').value = preset.character_position || 'system';
                document.getElementById('preset-include-examples').checked = preset.include_examples !== false;
                document.getElementById('preset-example-separator').value = preset.example_separator || '<START>';
                
                updateSlider('preset-temp', preset.temperature || 0.7);
                updateSlider('preset-tokens', preset.max_tokens || 2000);
                updateSlider('preset-response-length', preset.max_response_length || 2000);
                updateSlider('preset-topp', preset.top_p || 1.0);
                updateSlider('preset-freq', preset.frequency_penalty || 0.0);
                updateSlider('preset-pres', preset.presence_penalty || 0.0);
                
                showMessage('presets-message', `Loaded preset: ${name}`, 'success');
            } catch (error) {
                showMessage('presets-message', 'Error loading preset: ' + error.message, 'error');
            }
        }
        
        // Prompt sections management
        let promptSectionCounter = 0;
        
        function addPromptSection(role = 'system', content = '', order = null, enabled = true) {
            const container = document.getElementById('prompt-sections-container');
            const sectionId = `prompt-section-${promptSectionCounter++}`;
            const actualOrder = order !== null ? order : container.children.length;
            
            const sectionHtml = `
                <div class="prompt-section" data-section-id="${sectionId}" data-order="${actualOrder}">
                    <div class="prompt-section-header">
                        <select class="prompt-section-role" onchange="updateSectionRole('${sectionId}', this.value)">
                            <option value="system" ${role === 'system' ? 'selected' : ''}>System</option>
                            <option value="user" ${role === 'user' ? 'selected' : ''}>User</option>
                            <option value="assistant" ${role === 'assistant' ? 'selected' : ''}>Assistant</option>
                        </select>
                        <div class="prompt-section-controls">
                            <label style="display: flex; align-items: center; gap: 5px; margin-right: 10px; cursor: pointer;">
                                <input type="checkbox" class="prompt-section-enabled" ${enabled ? 'checked' : ''} style="width: auto;" title="Enable/Disable this section">
                                <span style="font-size: 0.9em; color: #666;">Active</span>
                            </label>
                            <div class="prompt-section-order-btns">
                                <button type="button" class="btn btn-secondary btn-icon" onclick="moveSectionUp('${sectionId}')" title="Move up">▲</button>
                                <button type="button" class="btn btn-secondary btn-icon" onclick="moveSectionDown('${sectionId}')" title="Move down">▼</button>
                            </div>
                            <button type="button" class="btn btn-danger btn-sm" onclick="removePromptSection('${sectionId}')">Delete</button>
                        </div>
                    </div>
                    <textarea class="prompt-section-content" placeholder="Enter ${role} message content...">${content}</textarea>
                </div>
            `;
            
            container.insertAdjacentHTML('beforeend', sectionHtml);
            reorderSections();
        }
        
        function removePromptSection(sectionId) {
            const section = document.querySelector(`[data-section-id="${sectionId}"]`);
            if (section) {
                section.remove();
                reorderSections();
            }
        }
        
        function moveSectionUp(sectionId) {
            const section = document.querySelector(`[data-section-id="${sectionId}"]`);
            if (section && section.previousElementSibling) {
                section.parentNode.insertBefore(section, section.previousElementSibling);
                reorderSections();
            }
        }
        
        function moveSectionDown(sectionId) {
            const section = document.querySelector(`[data-section-id="${sectionId}"]`);
            if (section && section.nextElementSibling) {
                section.parentNode.insertBefore(section.nextElementSibling, section);
                reorderSections();
            }
        }
        
        function updateSectionRole(sectionId, role) {
            const section = document.querySelector(`[data-section-id="${sectionId}"]`);
            const textarea = section.querySelector('.prompt-section-content');
            textarea.placeholder = `Enter ${role} message content...`;
        }
        
        function reorderSections() {
            const container = document.getElementById('prompt-sections-container');
            const sections = container.querySelectorAll('.prompt-section');
            sections.forEach((section, index) => {
                section.setAttribute('data-order', index);
            });
        }
        
        function getPromptSections() {
            const container = document.getElementById('prompt-sections-container');
            const sections = container.querySelectorAll('.prompt-section');
            const result = [];
            
            sections.forEach((section, index) => {
                const role = section.querySelector('.prompt-section-role').value;
                const content = section.querySelector('.prompt-section-content').value;
                const enabled = section.querySelector('.prompt-section-enabled').checked;
                result.push({
                    id: section.getAttribute('data-section-id'),
                    role: role,
                    content: content,
                    order: index,
                    enabled: enabled
                });
            });
            
            return result;
        }
        
        function loadPromptSections(sections) {
            const container = document.getElementById('prompt-sections-container');
            container.innerHTML = '';
            promptSectionCounter = 0;
            
            if (!sections || sections.length === 0) {
                // Default: create one system section
                addPromptSection('system', 'You are a helpful AI assistant.', null, true);
            } else {
                // Sort by order and load sections
                sections.sort((a, b) => (a.order || 0) - (b.order || 0));
                sections.forEach(section => {
                    addPromptSection(section.role, section.content, section.order, section.enabled !== false);
                });
            }
        }
        
        // Default preset prompt sections management
        let defaultPromptSectionCounter = 0;
        
        function addDefaultPromptSection(role = 'system', content = '', order = null, enabled = true) {
            const container = document.getElementById('default-prompt-sections-container');
            const sectionId = `default-prompt-section-${defaultPromptSectionCounter++}`;
            const actualOrder = order !== null ? order : container.children.length;
            
            const sectionHtml = `
                <div class="prompt-section" data-section-id="${sectionId}" data-order="${actualOrder}">
                    <div class="prompt-section-header">
                        <select class="prompt-section-role" onchange="updateDefaultSectionRole('${sectionId}', this.value)">
                            <option value="system" ${role === 'system' ? 'selected' : ''}>System</option>
                            <option value="user" ${role === 'user' ? 'selected' : ''}>User</option>
                            <option value="assistant" ${role === 'assistant' ? 'selected' : ''}>Assistant</option>
                        </select>
                        <div class="prompt-section-controls">
                            <label style="display: flex; align-items: center; gap: 5px; margin-right: 10px; cursor: pointer;">
                                <input type="checkbox" class="prompt-section-enabled" ${enabled ? 'checked' : ''} style="width: auto;" title="Enable/Disable this section">
                                <span style="font-size: 0.9em; color: #666;">Active</span>
                            </label>
                            <div class="prompt-section-order-btns">
                                <button type="button" class="btn btn-secondary btn-icon" onclick="moveDefaultSectionUp('${sectionId}')" title="Move up">▲</button>
                                <button type="button" class="btn btn-secondary btn-icon" onclick="moveDefaultSectionDown('${sectionId}')" title="Move down">▼</button>
                            </div>
                            <button type="button" class="btn btn-danger btn-sm" onclick="removeDefaultPromptSection('${sectionId}')">Delete</button>
                        </div>
                    </div>
                    <textarea class="prompt-section-content" placeholder="Enter ${role} message content...">${content}</textarea>
                </div>
            `;
            
            container.insertAdjacentHTML('beforeend', sectionHtml);
            reorderDefaultSections();
        }
        
        function removeDefaultPromptSection(sectionId) {
            const section = document.querySelector(`[data-section-id="${sectionId}"]`);
            if (section) {
                section.remove();
                reorderDefaultSections();
            }
        }
        
        function moveDefaultSectionUp(sectionId) {
            const section = document.querySelector(`[data-section-id="${sectionId}"]`);
            if (section && section.previousElementSibling) {
                section.parentNode.insertBefore(section, section.previousElementSibling);
                reorderDefaultSections();
            }
        }
        
        function moveDefaultSectionDown(sectionId) {
            const section = document.querySelector(`[data-section-id="${sectionId}"]`);
            if (section && section.nextElementSibling) {
                section.parentNode.insertBefore(section.nextElementSibling, section);
                reorderDefaultSections();
            }
        }
        
        function updateDefaultSectionRole(sectionId, role) {
            const section = document.querySelector(`[data-section-id="${sectionId}"]`);
            const textarea = section.querySelector('.prompt-section-content');
            textarea.placeholder = `Enter ${role} message content...`;
        }
        
        function reorderDefaultSections() {
            const container = document.getElementById('default-prompt-sections-container');
            const sections = container.querySelectorAll('.prompt-section');
            sections.forEach((section, index) => {
                section.setAttribute('data-order', index);
            });
        }
        
        function getDefaultPromptSections() {
            const container = document.getElementById('default-prompt-sections-container');
            const sections = container.querySelectorAll('.prompt-section');
            const result = [];
            
            sections.forEach((section, index) => {
                const role = section.querySelector('.prompt-section-role').value;
                const content = section.querySelector('.prompt-section-content').value;
                const enabled = section.querySelector('.prompt-section-enabled').checked;
                result.push({
                    id: section.getAttribute('data-section-id'),
                    role: role,
                    content: content,
                    order: index,
                    enabled: enabled
                });
            });
            
            return result;
        }
        
        function loadDefaultPromptSections(sections) {
            const container = document.getElementById('default-prompt-sections-container');
            container.innerHTML = '';
            defaultPromptSectionCounter = 0;
            
            if (!sections || sections.length === 0) {
                // Default: create one system section
                addDefaultPromptSection('system', 'You are a helpful AI assistant.', null, true);
            } else {
                // Sort by order and load sections
                sections.sort((a, b) => (a.order || 0) - (b.order || 0));
                sections.forEach(section => {
                    addDefaultPromptSection(section.role, section.content, section.order, section.enabled !== false);
                });
            }
        }
        
        // Collapsible functionality
        function toggleCollapsible(contentId) {
            const content = document.getElementById(contentId);
            const header = content.previousElementSibling;
            const icon = header.querySelector('.collapsible-icon');
            
            if (content.classList.contains('open')) {
                content.classList.remove('open');
                icon.classList.remove('open');
            } else {
                content.classList.add('open');
                icon.classList.add('open');
            }
        }
        
        // Load preset into default preset configuration
        async function loadPresetToDefault() {
            const presetName = document.getElementById('default-preset-dropdown').value;
            if (!presetName) return;
            
            try {
                const response = await fetch(`/api/presets/${presetName}`);
                const preset = await response.json();
                
                // Load prompt sections
                if (preset.prompt_sections && preset.prompt_sections.length > 0) {
                    loadDefaultPromptSections(preset.prompt_sections);
                } else if (preset.system_prompt) {
                    loadDefaultPromptSections([{
                        role: 'system',
                        content: preset.system_prompt,
                        order: 0,
                        enabled: true
                    }]);
                } else {
                    loadDefaultPromptSections([]);
                }
                
                // Load other settings
                document.getElementById('temperature').value = preset.temperature || 0.7;
                document.getElementById('max-tokens').value = preset.max_tokens || 2000;
                document.getElementById('max-response-length').value = preset.max_response_length || 2000;
                document.getElementById('top-p').value = preset.top_p || 1.0;
                document.getElementById('frequency-penalty').value = preset.frequency_penalty || 0.0;
                document.getElementById('presence-penalty').value = preset.presence_penalty || 0.0;
                
                updateSlider('temp', preset.temperature || 0.7);
                updateSlider('tokens', preset.max_tokens || 2000);
                updateSlider('response-length', preset.max_response_length || 2000);
                updateSlider('topp', preset.top_p || 1.0);
                updateSlider('freq', preset.frequency_penalty || 0.0);
                updateSlider('pres', preset.presence_penalty || 0.0);
                
                showMessage('config-message', `Loaded preset "${presetName}" into default configuration`, 'success');
            } catch (error) {
                showMessage('config-message', 'Error loading preset: ' + error.message, 'error');
            }
        }
        
        // Load presets into dropdown
        async function loadPresetsDropdown() {
            try {
                const response = await fetch('/api/presets');
                const data = await response.json();
                
                const dropdown = document.getElementById('default-preset-dropdown');
                dropdown.innerHTML = '<option value="">-- Select a preset to load --</option>';
                
                data.presets.forEach(preset => {
                    const option = document.createElement('option');
                    option.value = preset;
                    option.textContent = preset;
                    dropdown.appendChild(option);
                });
            } catch (error) {
                console.error('Error loading presets dropdown:', error);
            }
        }
        
        async function savePreset() {
            const name = document.getElementById('preset-name').value;
            if (!name) {
                showMessage('presets-message', 'Please enter a preset name', 'error');
                return;
            }
            
            try {
                const promptSections = getPromptSections();
                const preset = {
                    prompt_sections: promptSections,
                    temperature: parseFloat(document.getElementById('preset-temperature').value),
                    max_tokens: parseInt(document.getElementById('preset-max-tokens').value),
                    max_response_length: parseInt(document.getElementById('preset-max-response-length').value),
                    top_p: parseFloat(document.getElementById('preset-top-p').value),
                    frequency_penalty: parseFloat(document.getElementById('preset-frequency-penalty').value),
                    presence_penalty: parseFloat(document.getElementById('preset-presence-penalty').value),
                    frequency_penalty_enabled: document.getElementById('preset-frequency-penalty-enabled').checked,
                    presence_penalty_enabled: document.getElementById('preset-presence-penalty-enabled').checked,
                    prompt_format: document.getElementById('preset-prompt-format').value,
                    character_position: document.getElementById('preset-character-position').value,
                    include_examples: document.getElementById('preset-include-examples').checked,
                    example_separator: document.getElementById('preset-example-separator').value
                };
                
                const response = await fetch(`/api/presets/${name}`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify(preset)
                });
                
                const result = await response.json();
                showMessage('presets-message', result.message, result.status === 'success' ? 'success' : 'error');
                loadPresetsList();
            } catch (error) {
                showMessage('presets-message', 'Error saving preset: ' + error.message, 'error');
            }
        }
        
        async function deletePreset(name) {
            if (!confirm(`Delete preset "${name}"?`)) return;
            
            try {
                const response = await fetch(`/api/presets/${name}`, {
                    method: 'DELETE'
                });
                
                const result = await response.json();
                showMessage('presets-message', result.message, result.status === 'success' ? 'success' : 'error');
                loadPresetsList();
            } catch (error) {
                showMessage('presets-message', 'Error deleting preset: ' + error.message, 'error');
            }
        }
        
        async function exportPreset() {
            const name = document.getElementById('preset-name').value;
            if (!name) {
                showMessage('presets-message', 'Please select a preset to export', 'error');
                return;
            }
            
            try {
                const response = await fetch(`/api/presets/${name}/export`);
                const data = await response.json();
                
                const blob = new Blob([data.preset], {type: 'application/json'});
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${name}.json`;
                a.click();
                
                showMessage('presets-message', 'Preset exported', 'success');
            } catch (error) {
                showMessage('presets-message', 'Error exporting preset: ' + error.message, 'error');
            }
        }
        
        function showImportPreset() {
            document.getElementById('import-preset-section').style.display = 'block';
        }
        
        function cancelImportPreset() {
            document.getElementById('import-preset-section').style.display = 'none';
            document.getElementById('import-preset-json').value = '';
        }
        
        async function importPreset() {
            const name = document.getElementById('preset-name').value;
            const presetJson = document.getElementById('import-preset-json').value;
            
            if (!name || !presetJson) {
                showMessage('presets-message', 'Please enter preset name and JSON', 'error');
                return;
            }
            
            try {
                const response = await fetch('/api/presets/import', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({name, preset: presetJson})
                });
                
                const result = await response.json();
                showMessage('presets-message', result.message, result.status === 'success' ? 'success' : 'error');
                cancelImportPreset();
                loadPresetsList();
            } catch (error) {
                showMessage('presets-message', 'Error importing preset: ' + error.message, 'error');
            }
        }
        
        // Character functions
        async function loadCharactersList() {
            try {
                const response = await fetch('/api/characters');
                const data = await response.json();
                
                const listEl = document.getElementById('characters-list');
                listEl.innerHTML = '';
                
                if (data.characters.length === 0) {
                    listEl.innerHTML = '<p>No characters available</p>';
                    return;
                }
                
                data.characters.forEach(character => {
                    const item = document.createElement('div');
                    item.className = 'list-item';
                    item.innerHTML = `
                        <span>${character}</span>
                        <div>
                            <button class="btn btn-secondary" onclick="selectCharacter('${character}')">Load</button>
                            <button class="btn btn-danger" onclick="deleteCharacter('${character}')">Delete</button>
                        </div>
                    `;
                    listEl.appendChild(item);
                });
            } catch (error) {
                console.error('Error loading characters:', error);
            }
        }
        
        async function selectCharacter(name) {
            try {
                const response = await fetch(`/api/characters/${name}`);
                const character = await response.json();
                
                document.getElementById('character-name').value = name;
                document.getElementById('character-display-name').value = character.name || '';
                document.getElementById('character-personality').value = character.personality || '';
                document.getElementById('character-description').value = character.description || '';
                document.getElementById('character-scenario').value = character.scenario || '';
                document.getElementById('character-system-prompt').value = character.system_prompt || '';
                document.getElementById('character-avatar-url').value = character.avatar_url || '';
                
                showMessage('characters-message', `Loaded character: ${name}`, 'success');
            } catch (error) {
                showMessage('characters-message', 'Error loading character: ' + error.message, 'error');
            }
        }
        
        async function saveCharacter() {
            const name = document.getElementById('character-name').value;
            if (!name) {
                showMessage('characters-message', 'Please enter a character name', 'error');
                return;
            }
            
            try {
                const character = {
                    name: document.getElementById('character-display-name').value,
                    personality: document.getElementById('character-personality').value,
                    description: document.getElementById('character-description').value,
                    scenario: document.getElementById('character-scenario').value,
                    system_prompt: document.getElementById('character-system-prompt').value
                };
                
                // Handle avatar - check if upload or URL
                const avatarMethod = document.querySelector('input[name="avatar-method"]:checked').value;
                const fileInput = document.getElementById('character-avatar-file');
                
                if (avatarMethod === 'upload' && fileInput.files.length > 0) {
                    // Upload the image first
                    const formData = new FormData();
                    formData.append('avatar', fileInput.files[0]);
                    formData.append('character_name', name);
                    
                    const uploadResponse = await fetch('/api/characters/upload_avatar', {
                        method: 'POST',
                        body: formData
                    });
                    
                    const uploadResult = await uploadResponse.json();
                    if (uploadResult.status === 'success') {
                        character.avatar_url = uploadResult.avatar_url;
                    } else {
                        showMessage('characters-message', 'Error uploading avatar: ' + uploadResult.message, 'error');
                        return;
                    }
                } else {
                    // Use URL method
                    character.avatar_url = document.getElementById('character-avatar-url').value;
                }
                
                const response = await fetch(`/api/characters/${name}`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify(character)
                });
                
                const result = await response.json();
                showMessage('characters-message', result.message, result.status === 'success' ? 'success' : 'error');
                loadCharactersList();
            } catch (error) {
                showMessage('characters-message', 'Error saving character: ' + error.message, 'error');
            }
        }
        
        async function deleteCharacter(name) {
            if (!confirm(`Delete character "${name}"?`)) return;
            
            try {
                const response = await fetch(`/api/characters/${name}`, {
                    method: 'DELETE'
                });
                
                const result = await response.json();
                showMessage('characters-message', result.message, result.status === 'success' ? 'success' : 'error');
                loadCharactersList();
            } catch (error) {
                showMessage('characters-message', 'Error deleting character: ' + error.message, 'error');
            }
        }
        
        async function exportCharacter() {
            const name = document.getElementById('character-name').value;
            if (!name) {
                showMessage('characters-message', 'Please select a character to export', 'error');
                return;
            }
            
            try {
                const response = await fetch(`/api/characters/${name}/export`);
                const data = await response.json();
                
                const blob = new Blob([data.character], {type: 'application/json'});
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${name}.json`;
                a.click();
                
                showMessage('characters-message', 'Character exported', 'success');
            } catch (error) {
                showMessage('characters-message', 'Error exporting character: ' + error.message, 'error');
            }
        }
        
        function showImportCharacter() {
            document.getElementById('import-character-section').style.display = 'block';
        }
        
        function cancelImportCharacter() {
            document.getElementById('import-character-section').style.display = 'none';
            document.getElementById('import-character-json').value = '';
        }
        
        async function importCharacter() {
            const name = document.getElementById('character-name').value;
            const characterJson = document.getElementById('import-character-json').value;
            
            if (!name || !characterJson) {
                showMessage('characters-message', 'Please enter character name and JSON', 'error');
                return;
            }
            
            try {
                const response = await fetch('/api/characters/import', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({name, character: characterJson})
                });
                
                const result = await response.json();
                showMessage('characters-message', result.message, result.status === 'success' ? 'success' : 'error');
                cancelImportCharacter();
                loadCharactersList();
            } catch (error) {
                showMessage('characters-message', 'Error importing character: ' + error.message, 'error');
            }
        }
        
        // User Characters Management
        async function loadUserCharactersList() {
            try {
                const response = await fetch('/api/user_characters');
                const data = await response.json();
                const characters = data.characters;
                
                const listEl = document.getElementById('user-characters-list');
                listEl.innerHTML = '';
                
                const characterNames = Object.keys(characters);
                if (characterNames.length === 0) {
                    listEl.innerHTML = '<p style="color: #999;">No user characters saved yet.</p>';
                    return;
                }
                
                characterNames.forEach(name => {
                    const charData = characters[name];
                    const item = document.createElement('div');
                    item.style.cssText = 'background: #f8f9fa; padding: 15px; margin: 10px 0; border-radius: 5px; border-left: 4px solid #667eea;';
                    
                    const description = charData.description.length > 150 ? 
                        charData.description.substring(0, 150) + '...' : 
                        charData.description;
                    
                    const sheetBadge = charData.sheet_enabled && charData.sheet ? 
                        '<span style="background: #10b981; color: white; padding: 2px 8px; border-radius: 4px; font-size: 0.8em; margin-left: 10px;">Sheet Enabled</span>' : '';
                    
                    item.innerHTML = `
                        <div style="display: flex; justify-content: space-between; align-items: start;">
                            <div style="flex: 1;">
                                <strong style="font-size: 1.1em; color: #2c3e50;">${name}</strong>${sheetBadge}
                                <p style="margin: 5px 0 0 0; color: #666;">${description}</p>
                            </div>
                            <div style="display: flex; gap: 5px;">
                                <button class="btn btn-secondary" style="padding: 5px 10px; font-size: 0.9em;" onclick="editUserCharacter('${name}')">Edit</button>
                                <button class="btn btn-danger" style="padding: 5px 10px; font-size: 0.9em;" onclick="deleteUserCharacter('${name}')">Delete</button>
                            </div>
                        </div>
                    `;
                    listEl.appendChild(item);
                });
            } catch (error) {
                showMessage('user-characters-message', 'Error loading user characters: ' + error.message, 'error');
            }
        }
        
        async function saveUserCharacter() {
            const name = document.getElementById('user-character-name').value;
            const description = document.getElementById('user-character-description').value;
            const sheet = document.getElementById('user-character-sheet').value;
            const sheet_enabled = document.getElementById('user-character-sheet-enabled').checked;
            
            if (!name || !description) {
                showMessage('user-characters-message', 'Please enter both name and description', 'error');
                return;
            }
            
            try {
                const response = await fetch(`/api/user_characters/${name}`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({description, sheet, sheet_enabled})
                });
                
                const result = await response.json();
                showMessage('user-characters-message', result.message, result.status === 'success' ? 'success' : 'error');
                loadUserCharactersList();
                
                // Clear form
                document.getElementById('user-character-name').value = '';
                document.getElementById('user-character-description').value = '';
                document.getElementById('user-character-sheet').value = '';
                document.getElementById('user-character-sheet-enabled').checked = false;
            } catch (error) {
                showMessage('user-characters-message', 'Error saving user character: ' + error.message, 'error');
            }
        }
        
        async function loadUserCharacter() {
            const name = document.getElementById('user-character-name').value;
            
            if (!name) {
                showMessage('user-characters-message', 'Please enter a character name', 'error');
                return;
            }
            
            try {
                const response = await fetch(`/api/user_characters/${name}`);
                if (!response.ok) {
                    showMessage('user-characters-message', 'User character not found', 'error');
                    return;
                }
                
                const charData = await response.json();
                document.getElementById('user-character-name').value = charData.name;
                document.getElementById('user-character-description').value = charData.description;
                document.getElementById('user-character-sheet').value = charData.sheet || '';
                document.getElementById('user-character-sheet-enabled').checked = charData.sheet_enabled || false;
                showMessage('user-characters-message', 'User character loaded', 'success');
            } catch (error) {
                showMessage('user-characters-message', 'Error loading user character: ' + error.message, 'error');
            }
        }
        
        async function editUserCharacter(name) {
            try {
                const response = await fetch(`/api/user_characters/${name}`);
                const charData = await response.json();
                
                document.getElementById('user-character-name').value = charData.name;
                document.getElementById('user-character-description').value = charData.description;
                document.getElementById('user-character-sheet').value = charData.sheet || '';
                document.getElementById('user-character-sheet-enabled').checked = charData.sheet_enabled || false;
                
                // Scroll to form
                document.getElementById('user-character-name').scrollIntoView({ behavior: 'smooth' });
                showMessage('user-characters-message', 'Editing user character: ' + name, 'success');
            } catch (error) {
                showMessage('user-characters-message', 'Error loading user character: ' + error.message, 'error');
            }
        }
        
        async function deleteUserCharacter(name) {
            if (!confirm(`Delete user character "${name}"?`)) {
                return;
            }
            
            try {
                const response = await fetch(`/api/user_characters/${name}`, {
                    method: 'DELETE'
                });
                
                const result = await response.json();
                showMessage('user-characters-message', result.message, result.status === 'success' ? 'success' : 'error');
                loadUserCharactersList();
            } catch (error) {
                showMessage('user-characters-message', 'Error deleting user character: ' + error.message, 'error');
            }
        }
        
        async function exportUserCharacters() {
            try {
                const response = await fetch('/api/user_characters/export');
                const data = await response.json();
                
                const blob = new Blob([data.characters], {type: 'application/json'});
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'user_characters.json';
                a.click();
                
                showMessage('user-characters-message', 'User characters exported', 'success');
            } catch (error) {
                showMessage('user-characters-message', 'Error exporting user characters: ' + error.message, 'error');
            }
        }
        
        function showImportUserCharacters() {
            document.getElementById('import-user-characters-section').style.display = 'block';
        }
        
        function cancelImportUserCharacters() {
            document.getElementById('import-user-characters-section').style.display = 'none';
            document.getElementById('import-user-characters-json').value = '';
        }
        
        async function importUserCharacters() {
            const charactersJson = document.getElementById('import-user-characters-json').value;
            
            if (!charactersJson) {
                showMessage('user-characters-message', 'Please enter JSON data', 'error');
                return;
            }
            
            try {
                const response = await fetch('/api/user_characters/import', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({characters: charactersJson})
                });
                
                const result = await response.json();
                showMessage('user-characters-message', result.message, result.status === 'success' ? 'success' : 'error');
                cancelImportUserCharacters();
                loadUserCharactersList();
            } catch (error) {
                showMessage('user-characters-message', 'Error importing user characters: ' + error.message, 'error');
            }
        }
        
        // Lorebook Management
        async function loadLorebookList() {
            // Load the lorebooks list first
            await loadLorebooksList();
            
            // Then load entries if a lorebook is selected
            if (currentLorebookName) {
                await loadLorebookEntriesForCurrent();
            }
        }
        
        async function saveLorebookEntry() {
            const key = document.getElementById('lorebook-key').value.trim();
            const content = document.getElementById('lorebook-content').value.trim();
            const keywordsStr = document.getElementById('lorebook-keywords').value.trim();
            const activationType = document.getElementById('lorebook-activation-type').value;
            
            if (!key || !content) {
                showMessage('lorebook-message', 'Please enter both key and content', 'error');
                return;
            }
            
            // Ensure we have a lorebook selected
            if (!currentLorebookName) {
                showMessage('lorebook-message', 'Please select or create a lorebook first', 'error');
                return;
            }
            
            const keywords = keywordsStr ? keywordsStr.split(',').map(k => k.trim()).filter(k => k) : [];
            
            try {
                const response = await fetch(`/api/lorebook/${encodeURIComponent(key)}`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        content: content,
                        keywords: keywords,
                        activation_type: activationType,
                        lorebook_name: currentLorebookName
                    })
                });
                
                const result = await response.json();
                showMessage('lorebook-message', result.message, result.status === 'success' ? 'success' : 'error');
                clearLorebookForm();
                loadLorebookEntriesForCurrent();
                loadLorebooksList(); // Refresh to update entry count
            } catch (error) {
                showMessage('lorebook-message', 'Error saving entry: ' + error.message, 'error');
            }
        }
        
        async function editLorebookEntry(key) {
            if (!currentLorebookName) return;
            
            try {
                const response = await fetch(`/api/lorebooks/${encodeURIComponent(currentLorebookName)}`);
                const lorebook = await response.json();
                const entry = lorebook.entries[key];
                
                if (!entry) {
                    showMessage('lorebook-message', 'Entry not found', 'error');
                    return;
                }
                
                document.getElementById('lorebook-key').value = entry.key;
                document.getElementById('lorebook-content').value = entry.content;
                document.getElementById('lorebook-keywords').value = (entry.keywords || []).join(', ');
                
                // Handle activation_type with backward compatibility
                let activationType = entry.activation_type;
                if (!activationType) {
                    // Fall back to always_active for old entries
                    activationType = entry.always_active ? 'constant' : 'normal';
                }
                document.getElementById('lorebook-activation-type').value = activationType;
                
                // Scroll to top
                document.getElementById('lorebook').scrollTop = 0;
            } catch (error) {
                showMessage('lorebook-message', 'Error loading entry: ' + error.message, 'error');
            }
        }
        
        async function deleteLorebookEntry(key) {
            if (!currentLorebookName) return;
            
            if (!confirm(`Delete lorebook entry "${key}"?`)) {
                return;
            }
            
            try {
                const response = await fetch(`/api/lorebook/${encodeURIComponent(key)}`, {
                    method: 'DELETE',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        lorebook_name: currentLorebookName
                    })
                });
                
                const result = await response.json();
                showMessage('lorebook-message', result.message, result.status === 'success' ? 'success' : 'error');
                loadLorebookEntriesForCurrent();
                loadLorebooksList(); // Refresh to update entry count
            } catch (error) {
                showMessage('lorebook-message', 'Error deleting entry: ' + error.message, 'error');
            }
        }
        
        function clearLorebookForm() {
            document.getElementById('lorebook-key').value = '';
            document.getElementById('lorebook-content').value = '';
            document.getElementById('lorebook-keywords').value = '';
            document.getElementById('lorebook-activation-type').value = 'normal';
        }
        
        async function exportLorebook() {
            try {
                const response = await fetch('/api/lorebook/export');
                const data = await response.json();
                
                const blob = new Blob([data.lorebook], {type: 'application/json'});
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'lorebook.json';
                a.click();
                
                showMessage('lorebook-message', 'Lorebook exported successfully', 'success');
            } catch (error) {
                showMessage('lorebook-message', 'Error exporting lorebook: ' + error.message, 'error');
            }
        }
        
        function showImportLorebook() {
            document.getElementById('import-lorebook-section').style.display = 'block';
        }
        
        function cancelImportLorebook() {
            document.getElementById('import-lorebook-section').style.display = 'none';
            document.getElementById('import-lorebook-json').value = '';
        }
        
        async function importLorebook() {
            const lorebookJson = document.getElementById('import-lorebook-json').value;
            const merge = document.getElementById('lorebook-merge').checked;
            
            if (!lorebookJson) {
                showMessage('lorebook-message', 'Please enter JSON data', 'error');
                return;
            }
            
            try {
                const response = await fetch('/api/lorebook/import', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        lorebook: lorebookJson,
                        merge: merge
                    })
                });
                
                const result = await response.json();
                showMessage('lorebook-message', result.message, result.status === 'success' ? 'success' : 'error');
                cancelImportLorebook();
                loadLorebooksList();
                loadLorebookList();
            } catch (error) {
                showMessage('lorebook-message', 'Error importing lorebook: ' + error.message, 'error');
            }
        }
        
        // Multiple Lorebooks Management
        let currentLorebookName = null;
        
        async function loadLorebooksList() {
            try {
                const response = await fetch('/api/lorebooks');
                const data = await response.json();
                const lorebooks = data.lorebooks || [];
                
                // Update selector
                const selector = document.getElementById('lorebook-selector');
                selector.innerHTML = '<option value="">-- Select a Lorebook --</option>';
                
                lorebooks.forEach(lb => {
                    const option = document.createElement('option');
                    option.value = lb.name;
                    option.textContent = `${lb.name} (${lb.entry_count} entries)${lb.enabled ? '' : ' [Disabled]'}`;
                    selector.appendChild(option);
                });
                
                // Select first lorebook if available and none selected
                if (!currentLorebookName && lorebooks.length > 0) {
                    currentLorebookName = lorebooks[0].name;
                    selector.value = currentLorebookName;
                    await onLorebookSelected();
                } else if (currentLorebookName) {
                    // If a lorebook is already selected, maintain the selection in the dropdown
                    selector.value = currentLorebookName;
                }
                
                // Update lorebooks list
                const listDiv = document.getElementById('lorebooks-list');
                listDiv.innerHTML = '';
                
                if (lorebooks.length === 0) {
                    listDiv.innerHTML = '<p style="color: #666;">No lorebooks created yet.</p>';
                    return;
                }
                
                lorebooks.forEach(lb => {
                    const itemDiv = document.createElement('div');
                    itemDiv.style.cssText = 'padding: 8px; margin: 4px 0; background: white; border-radius: 4px; display: flex; justify-content: space-between; align-items: center;';
                    
                    const statusColor = lb.enabled ? '#28a745' : '#dc3545';
                    const statusText = lb.enabled ? 'Enabled' : 'Disabled';
                    
                    // Handle both single character (backward compatibility) and multiple characters
                    let linkedText = ' - Global';
                    if (lb.linked_characters && lb.linked_characters.length > 0) {
                        linkedText = ` - Linked to: ${lb.linked_characters.join(', ')}`;
                    } else if (lb.linked_character) {
                        // Backward compatibility
                        linkedText = ` - Linked to: ${lb.linked_character}`;
                    }
                    
                    itemDiv.innerHTML = `
                        <div>
                            <strong>${lb.name}</strong>
                            <span style="color: ${statusColor}; margin-left: 10px; font-size: 0.9em;">● ${statusText}</span>
                            <div style="color: #666; font-size: 0.9em;">${lb.description || 'No description'}${linkedText} - ${lb.entry_count} entries</div>
                        </div>
                        <button class="btn btn-sm btn-secondary" onclick="selectLorebook('${lb.name}')">Select</button>
                    `;
                    listDiv.appendChild(itemDiv);
                });
            } catch (error) {
                showMessage('lorebook-message', 'Error loading lorebooks: ' + error.message, 'error');
            }
        }
        
        async function onLorebookSelected() {
            const selector = document.getElementById('lorebook-selector');
            const name = selector.value;
            
            if (!name) {
                document.getElementById('lorebook-info').style.display = 'none';
                currentLorebookName = null;
                return;
            }
            
            currentLorebookName = name;
            
            try {
                const response = await fetch(`/api/lorebooks/${encodeURIComponent(name)}`);
                const lorebook = await response.json();
                
                document.getElementById('current-lorebook-name').textContent = lorebook.name;
                document.getElementById('current-lorebook-description').textContent = lorebook.description || '';
                document.getElementById('lorebook-enabled').checked = lorebook.enabled || false;
                
                // Display linked character info (support both old and new format)
                const charSpan = document.getElementById('current-lorebook-character');
                if (lorebook.linked_characters && lorebook.linked_characters.length > 0) {
                    charSpan.textContent = `[Linked to: ${lorebook.linked_characters.join(', ')}]`;
                    charSpan.style.display = 'inline';
                } else if (lorebook.linked_character) {
                    // Backward compatibility
                    charSpan.textContent = `[Linked to: ${lorebook.linked_character}]`;
                    charSpan.style.display = 'inline';
                } else {
                    charSpan.textContent = '[Global]';
                    charSpan.style.display = 'inline';
                }
                
                document.getElementById('lorebook-info').style.display = 'block';
                
                // Load entries for this lorebook
                loadLorebookEntriesForCurrent();
            } catch (error) {
                showMessage('lorebook-message', 'Error loading lorebook: ' + error.message, 'error');
            }
        }
        
        async function loadLorebookEntriesForCurrent() {
            if (!currentLorebookName) return;
            
            try {
                const response = await fetch(`/api/lorebooks/${encodeURIComponent(currentLorebookName)}`);
                const lorebook = await response.json();
                const entries = lorebook.entries || {};
                
                const listDiv = document.getElementById('lorebook-list');
                listDiv.innerHTML = '';
                
                if (Object.keys(entries).length === 0) {
                    listDiv.innerHTML = '<p style="color: #666;">No entries in this lorebook yet.</p>';
                    return;
                }
                
                for (const [key, entry] of Object.entries(entries)) {
                    const entryDiv = document.createElement('div');
                    entryDiv.className = 'item';
                    
                    // Get activation type with backward compatibility
                    let activationType = entry.activation_type;
                    if (!activationType) {
                        activationType = entry.always_active ? 'constant' : 'normal';
                    }
                    
                    let statusText = '';
                    // Display activation type with color coding
                    if (activationType === 'constant') {
                        statusText += '<span style="color: #28a745; font-weight: bold;">● Constant (Always Active)</span>';
                    } else if (activationType === 'vectorized') {
                        statusText += '<span style="color: #007bff; font-weight: bold;">● Vectorized (Semantic)</span>';
                    } else {
                        statusText += '<span style="color: #6c757d; font-weight: bold;">● Normal (Keyword)</span>';
                    }
                    
                    if (entry.keywords && entry.keywords.length > 0) {
                        statusText += (statusText ? ' | ' : '') + `Keywords: ${entry.keywords.join(', ')}`;
                    }
                    
                    entryDiv.innerHTML = `
                        <div>
                            <strong>${key}</strong>
                            ${statusText ? `<div style="font-size: 0.9em; color: #666; margin-top: 4px;">${statusText}</div>` : ''}
                            <div style="margin-top: 8px; color: #333;">${entry.content.substring(0, 150)}${entry.content.length > 150 ? '...' : ''}</div>
                        </div>
                        <div style="display: flex; gap: 8px;">
                            <button class="btn btn-sm btn-secondary" onclick="editLorebookEntry('${key}')">Edit</button>
                            <button class="btn btn-sm btn-danger" onclick="deleteLorebookEntry('${key}')">Delete</button>
                        </div>
                    `;
                    listDiv.appendChild(entryDiv);
                }
            } catch (error) {
                showMessage('lorebook-message', 'Error loading entries: ' + error.message, 'error');
            }
        }
        
        function selectLorebook(name) {
            document.getElementById('lorebook-selector').value = name;
            onLorebookSelected();
        }
        
        async function toggleCurrentLorebook() {
            if (!currentLorebookName) return;
            
            try {
                const response = await fetch(`/api/lorebooks/${encodeURIComponent(currentLorebookName)}/toggle`, {
                    method: 'POST'
                });
                
                const result = await response.json();
                showMessage('lorebook-message', result.message, result.status === 'success' ? 'success' : 'error');
                loadLorebooksList();
            } catch (error) {
                showMessage('lorebook-message', 'Error toggling lorebook: ' + error.message, 'error');
            }
        }
        
        async function showCreateLorebookDialog() {
            document.getElementById('create-lorebook-dialog').style.display = 'block';
            document.getElementById('new-lorebook-name').value = '';
            document.getElementById('new-lorebook-description').value = '';
            
            // Reset character selection
            newLorebookCharacters = [];
            updateNewLorebookCharactersList();
            
            // Populate character dropdown
            await populateCharacterSelector('new-lorebook-character-selector');
        }
        
        function cancelCreateLorebook() {
            document.getElementById('create-lorebook-dialog').style.display = 'none';
        }
        
        // Track selected characters for new lorebook
        let newLorebookCharacters = [];
        
        function addCharacterToNewLorebook() {
            const selector = document.getElementById('new-lorebook-character-selector');
            const characterName = selector.value;
            
            if (!characterName) return;
            
            // Don't add duplicates
            if (newLorebookCharacters.includes(characterName)) {
                return;
            }
            
            newLorebookCharacters.push(characterName);
            updateNewLorebookCharactersList();
        }
        
        function removeCharacterFromNewLorebook(characterName) {
            newLorebookCharacters = newLorebookCharacters.filter(c => c !== characterName);
            updateNewLorebookCharactersList();
        }
        
        function updateNewLorebookCharactersList() {
            const container = document.getElementById('new-lorebook-linked-characters');
            
            if (newLorebookCharacters.length === 0) {
                container.innerHTML = '<div style="color: #666; font-style: italic;">No characters linked (Global lorebook)</div>';
                return;
            }
            
            container.innerHTML = '';
            newLorebookCharacters.forEach(charName => {
                const charDiv = document.createElement('div');
                charDiv.style.cssText = 'display: flex; justify-content: space-between; align-items: center; padding: 5px; margin: 2px 0; background: white; border-radius: 3px;';
                charDiv.innerHTML = `
                    <span>${charName}</span>
                    <button class="btn btn-sm" style="background: #dc3545; color: white; padding: 2px 8px;" onclick="removeCharacterFromNewLorebook('${charName}')">−</button>
                `;
                container.appendChild(charDiv);
            });
        }
        
        async function createLorebook() {
            const name = document.getElementById('new-lorebook-name').value.trim();
            const description = document.getElementById('new-lorebook-description').value.trim();
            
            if (!name) {
                showMessage('lorebook-message', 'Please enter a lorebook name', 'error');
                return;
            }
            
            try {
                const response = await fetch('/api/lorebooks', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        name: name,
                        description: description,
                        enabled: true,
                        linked_characters: newLorebookCharacters.length > 0 ? newLorebookCharacters : null
                    })
                });
                
                const result = await response.json();
                showMessage('lorebook-message', result.message, result.status === 'success' ? 'success' : 'error');
                cancelCreateLorebook();
                loadLorebooksList();
                
                // Select the newly created lorebook
                if (result.status === 'success') {
                    currentLorebookName = name;
                    document.getElementById('lorebook-selector').value = name;
                    await onLorebookSelected();
                }
            } catch (error) {
                showMessage('lorebook-message', 'Error creating lorebook: ' + error.message, 'error');
            }
        }
        
        async function exportCurrentLorebook() {
            if (!currentLorebookName) return;
            
            try {
                const response = await fetch(`/api/lorebooks/${encodeURIComponent(currentLorebookName)}/export`);
                const data = await response.json();
                
                const blob = new Blob([data.lorebook], {type: 'application/json'});
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${currentLorebookName}.json`;
                a.click();
                
                showMessage('lorebook-message', 'Lorebook exported successfully', 'success');
            } catch (error) {
                showMessage('lorebook-message', 'Error exporting lorebook: ' + error.message, 'error');
            }
        }
        
        async function deleteCurrentLorebook() {
            if (!currentLorebookName) return;
            
            if (!confirm(`Delete lorebook "${currentLorebookName}" and all its entries?`)) {
                return;
            }
            
            try {
                const response = await fetch(`/api/lorebooks/${encodeURIComponent(currentLorebookName)}`, {
                    method: 'DELETE'
                });
                
                const result = await response.json();
                showMessage('lorebook-message', result.message, result.status === 'success' ? 'success' : 'error');
                
                currentLorebookName = null;
                document.getElementById('lorebook-selector').value = '';
                document.getElementById('lorebook-info').style.display = 'none';
                loadLorebooksList();
                loadLorebookList();
            } catch (error) {
                showMessage('lorebook-message', 'Error deleting lorebook: ' + error.message, 'error');
            }
        }
        
        // Track selected characters for edit lorebook
        let editLorebookCharacters = [];
        
        async function showEditLorebookDialog() {
            if (!currentLorebookName) return;
            
            try {
                const response = await fetch(`/api/lorebooks/${encodeURIComponent(currentLorebookName)}`);
                const lorebook = await response.json();
                
                document.getElementById('edit-lorebook-description').value = lorebook.description || '';
                
                // Initialize with current linked characters (support both formats)
                editLorebookCharacters = [];
                if (lorebook.linked_characters && lorebook.linked_characters.length > 0) {
                    editLorebookCharacters = [...lorebook.linked_characters];
                } else if (lorebook.linked_character) {
                    // Backward compatibility
                    editLorebookCharacters = [lorebook.linked_character];
                }
                
                updateEditLorebookCharactersList();
                await populateCharacterSelector('edit-lorebook-character-selector');
                document.getElementById('edit-lorebook-dialog').style.display = 'block';
            } catch (error) {
                showMessage('lorebook-message', 'Error loading lorebook data: ' + error.message, 'error');
            }
        }
        
        function cancelEditLorebook() {
            document.getElementById('edit-lorebook-dialog').style.display = 'none';
        }
        
        function addCharacterToEditLorebook() {
            const selector = document.getElementById('edit-lorebook-character-selector');
            const characterName = selector.value;
            
            if (!characterName) return;
            
            // Don't add duplicates
            if (editLorebookCharacters.includes(characterName)) {
                return;
            }
            
            editLorebookCharacters.push(characterName);
            updateEditLorebookCharactersList();
        }
        
        function removeCharacterFromEditLorebook(characterName) {
            editLorebookCharacters = editLorebookCharacters.filter(c => c !== characterName);
            updateEditLorebookCharactersList();
        }
        
        function updateEditLorebookCharactersList() {
            const container = document.getElementById('edit-lorebook-linked-characters');
            
            if (editLorebookCharacters.length === 0) {
                container.innerHTML = '<div style="color: #666; font-style: italic;">No characters linked (Global lorebook)</div>';
                return;
            }
            
            container.innerHTML = '';
            editLorebookCharacters.forEach(charName => {
                const charDiv = document.createElement('div');
                charDiv.style.cssText = 'display: flex; justify-content: space-between; align-items: center; padding: 5px; margin: 2px 0; background: white; border-radius: 3px;';
                charDiv.innerHTML = `
                    <span>${charName}</span>
                    <button class="btn btn-sm" style="background: #dc3545; color: white; padding: 2px 8px;" onclick="removeCharacterFromEditLorebook('${charName}')">−</button>
                `;
                container.appendChild(charDiv);
            });
        }
        
        async function saveLorebookMetadata() {
            if (!currentLorebookName) return;
            
            const description = document.getElementById('edit-lorebook-description').value.trim();
            
            try {
                const response = await fetch(`/api/lorebooks/${encodeURIComponent(currentLorebookName)}`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        description: description,
                        linked_characters: editLorebookCharacters.length > 0 ? editLorebookCharacters : null
                    })
                });
                
                const result = await response.json();
                showMessage('lorebook-message', result.message, result.status === 'success' ? 'success' : 'error');
                cancelEditLorebook();
                await loadLorebooksList();
                await onLorebookSelected();
            } catch (error) {
                showMessage('lorebook-message', 'Error updating lorebook: ' + error.message, 'error');
            }
        }
        
        async function populateCharacterSelector(selectId) {
            try {
                const response = await fetch('/api/characters');
                const data = await response.json();
                const characters = data.characters || [];
                
                const select = document.getElementById(selectId);
                select.innerHTML = '<option value="">Select a character to add...</option>';
                
                characters.forEach(charName => {
                    const option = document.createElement('option');
                    option.value = charName;
                    option.textContent = charName;
                    select.appendChild(option);
                });
            } catch (error) {
                console.error('Error loading characters:', error);
            }
        }
        
        async function populateCharacterDropdown(selectId, selectedCharacter = null) {
            try {
                const response = await fetch('/api/characters');
                const data = await response.json();
                const characters = data.characters || [];
                
                const select = document.getElementById(selectId);
                select.innerHTML = '<option value="">Global (no character link)</option>';
                
                characters.forEach(charName => {
                    const option = document.createElement('option');
                    option.value = charName;
                    option.textContent = charName;
                    if (selectedCharacter === charName) {
                        option.selected = true;
                    }
                    select.appendChild(option);
                });
            } catch (error) {
                console.error('Error loading characters:', error);
            }
        }
        
        // Server/Channel configuration functions (DEPRECATED - now using per-server config)
        // Kept for backward compatibility with Discord commands
        /*
        async function toggleServerChannels(serverId) {
            const content = document.getElementById(`server-content-${serverId}`);
            const icon = document.getElementById(`server-icon-${serverId}`);
            const channelsContainer = document.getElementById(`server-channels-${serverId}`);
            
            // If this server is currently open, close it
            if (content.classList.contains('open')) {
                content.classList.remove('open');
                icon.classList.remove('open');
                return;
            }
            
            // Close all other servers (accordion behavior)
            document.querySelectorAll('.collapsible-content.open').forEach(el => {
                el.classList.remove('open');
            });
            document.querySelectorAll('.collapsible-icon.open').forEach(el => {
                el.classList.remove('open');
            });
            
            // Open this server
            content.classList.add('open');
            icon.classList.add('open');
            
            // Check if channels are already loaded
            if (channelsContainer.dataset.loaded === 'true') {
                return;
            }
            
            // Show loading state
            channelsContainer.innerHTML = '<p style="color: #666;">Loading channels...</p>';
            
            // Load channels with pagination (default to page 1)
            await loadServerChannelsPage(serverId, 1);
        }
        
        async function loadServerChannelsPage(serverId, page = 1, search = '') {
            const channelsContainer = document.getElementById(`server-channels-${serverId}`);
            
            try {
                // Load preset, API config, and character options (cache these)
                if (!window.channelConfigOptions) {
                    const presetsResponse = await fetch('/api/presets');
                    const presetsData = await presetsResponse.json();
                    const presets = presetsData.presets || [];
                    
                    const apiConfigsResponse = await fetch('/api/api_configs');
                    const apiConfigsData = await apiConfigsResponse.json();
                    const apiConfigs = apiConfigsData.configs || [];
                    
                    const charactersResponse = await fetch('/api/characters');
                    const charactersData = await charactersResponse.json();
                    const characters = charactersData.characters || [];
                    
                    window.channelConfigOptions = { presets, apiConfigs, characters };
                }
                
                const { presets, apiConfigs, characters } = window.channelConfigOptions;
                
                // Fetch channels for this server with pagination
                const url = new URL(`/api/servers/${serverId}/channels`, window.location.origin);
                url.searchParams.set('page', page);
                url.searchParams.set('per_page', 100);
                if (search) {
                    url.searchParams.set('search', search);
                }
                
                const response = await fetch(url);
                const data = await response.json();
                const channels = data.channels || [];
                const total = data.total || 0;
                const currentPage = data.page || 1;
                const totalPages = data.total_pages || 1;
                const perPage = data.per_page || 100;
                
                if (total === 0) {
                    channelsContainer.innerHTML = '<p style="color: #666;">No text channels found.</p>';
                    return;
                }
                
                // Build pagination info and search bar
                let headerHtml = `
                    <div style="background: #f8f9fa; padding: 15px; border-radius: 5px; margin-bottom: 15px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                            <div style="font-weight: 600; color: #2c3e50;">
                                📋 Total Channels: ${total} ${search ? `(filtered)` : ''}
                            </div>
                            <div>
                                <input 
                                    type="text" 
                                    id="channel-search-${serverId}" 
                                    placeholder="🔍 Search channels..."
                                    value="${search}"
                                    style="padding: 8px 12px; border: 2px solid #ddd; border-radius: 5px; width: 250px;"
                                    onkeyup="if(event.key === 'Enter') searchServerChannels('${serverId}')"
                                />
                                <button 
                                    onclick="searchServerChannels('${serverId}')" 
                                    style="padding: 8px 15px; background: #667eea; color: white; border: none; border-radius: 5px; cursor: pointer; margin-left: 5px;"
                                >
                                    Search
                                </button>
                            </div>
                        </div>`;
                
                // Add pagination controls if needed
                if (totalPages > 1) {
                    headerHtml += `
                        <div style="display: flex; justify-content: center; align-items: center; gap: 10px; margin-top: 10px;">
                            <button 
                                onclick="loadServerChannelsPage('${serverId}', ${currentPage - 1}, '${search}')"
                                ${currentPage === 1 ? 'disabled' : ''}
                                style="padding: 6px 12px; background: ${currentPage === 1 ? '#ccc' : '#667eea'}; color: white; border: none; border-radius: 5px; cursor: ${currentPage === 1 ? 'not-allowed' : 'pointer'};"
                            >
                                ◀ Previous
                            </button>
                            <span style="color: #666;">
                                Page ${currentPage} of ${totalPages} (${(currentPage - 1) * perPage + 1}-${Math.min(currentPage * perPage, total)} of ${total})
                            </span>
                            <button 
                                onclick="loadServerChannelsPage('${serverId}', ${currentPage + 1}, '${search}')"
                                ${currentPage === totalPages ? 'disabled' : ''}
                                style="padding: 6px 12px; background: ${currentPage === totalPages ? '#ccc' : '#667eea'}; color: white; border: none; border-radius: 5px; cursor: ${currentPage === totalPages ? 'not-allowed' : 'pointer'};"
                            >
                                Next ▶
                            </button>
                        </div>`;
                }
                
                headerHtml += `</div>`;
                
                // Build channels HTML
                let channelsHtml = '';
                channels.forEach(channel => {
                    channelsHtml += `
                        <div style="background: white; padding: 15px; border-radius: 5px; margin-bottom: 10px; border-left: 4px solid #667eea;">
                            <h4 style="margin-top: 0; color: #34495e;"># ${channel.name}</h4>
                            <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 15px; margin-bottom: 10px;">
                                <div>
                                    <label style="display: block; margin-bottom: 5px; font-weight: 600; color: #2c3e50;">Preset</label>
                                    <select id="preset-${channel.id}" style="width: 100%; padding: 8px; border: 2px solid #ddd; border-radius: 5px;">
                                        <option value="">Default Preset</option>
                                        ${presets.map(p => `<option value="${p}" ${channel.preset === p ? 'selected' : ''}>${p}</option>`).join('')}
                                    </select>
                                </div>
                                <div>
                                    <label style="display: block; margin-bottom: 5px; font-weight: 600; color: #2c3e50;">API Config</label>
                                    <select id="api-${channel.id}" style="width: 100%; padding: 8px; border: 2px solid #ddd; border-radius: 5px;">
                                        <option value="">Default API Config</option>
                                        ${apiConfigs.map(cfg => `<option value="${cfg.name}" ${channel.api_config === cfg.name ? 'selected' : ''}>${cfg.display || cfg.name}</option>`).join('')}
                                    </select>
                                </div>
                                <div>
                                    <label style="display: block; margin-bottom: 5px; font-weight: 600; color: #2c3e50;">Character</label>
                                    <select id="character-${channel.id}" style="width: 100%; padding: 8px; border: 2px solid #ddd; border-radius: 5px;">
                                        <option value="">No Character</option>
                                        ${characters.map(c => `<option value="${c}" ${channel.character === c ? 'selected' : ''}>${c}</option>`).join('')}
                                    </select>
                                </div>
                            </div>
                            <button class="btn btn-primary btn-sm" onclick="saveChannelConfig('${channel.id}')">💾 Save Configuration</button>
                        </div>
                    `;
                });
                
                channelsContainer.innerHTML = headerHtml + channelsHtml;
                
                // Mark as loaded
                channelsContainer.dataset.loaded = 'true';
            } catch (error) {
                channelsContainer.innerHTML = `<p style="color: #d9534f;">Error loading channels: ${error.message}</p>`;
            }
        }
        
        function searchServerChannels(serverId) {
            const searchInput = document.getElementById(`channel-search-${serverId}`);
            const searchTerm = searchInput ? searchInput.value : '';
            loadServerChannelsPage(serverId, 1, searchTerm);
        }
        */
        
        async function loadDefaultConfig() {
            try {
                const response = await fetch('/api/config');
                const config = await response.json();
                
                // Display default preset
                const defaultPresetEl = document.getElementById('default-preset-display');
                if (defaultPresetEl) {
                    if (config.default_preset) {
                        // Handle new prompt_sections structure
                        if (config.default_preset.prompt_sections && config.default_preset.prompt_sections.length > 0) {
                            const firstSection = config.default_preset.prompt_sections[0];
                            const systemPrompt = firstSection.content || '';
                            const preview = systemPrompt.length > 60 ? systemPrompt.substring(0, 60) + '...' : systemPrompt;
                            defaultPresetEl.innerHTML = `<strong>Custom Preset:</strong> "${preview}"`;
                        }
                        // Handle old system_prompt structure for backward compatibility
                        else if (config.default_preset.system_prompt) {
                            const systemPrompt = config.default_preset.system_prompt;
                            const preview = systemPrompt.length > 60 ? systemPrompt.substring(0, 60) + '...' : systemPrompt;
                            defaultPresetEl.innerHTML = `<strong>Custom Preset:</strong> "${preview}"`;
                        } else {
                            defaultPresetEl.innerHTML = '<strong>Default Preset</strong> (from Configuration tab)';
                        }
                    } else {
                        defaultPresetEl.innerHTML = '<strong>Default Preset</strong> (from Configuration tab)';
                    }
                }
                
                // Display default API config
                const defaultApiEl = document.getElementById('default-api-display');
                if (defaultApiEl) {
                    if (config.openai_config) {
                        const baseUrl = config.openai_config.base_url || 'https://api.openai.com/v1';
                        const model = config.openai_config.model || 'gpt-3.5-turbo';
                        // Shorten the URL for display
                        const displayUrl = baseUrl.replace('https://', '').replace('/v1', '');
                        defaultApiEl.innerHTML = `<strong>${displayUrl}</strong> - ${model}`;
                    } else {
                        defaultApiEl.innerHTML = '<strong>OpenAI API</strong> (from Configuration tab)';
                    }
                }
            } catch (error) {
                console.error('Error loading default config:', error);
                // Safely update elements only if they exist
                const defaultPresetEl = document.getElementById('default-preset-display');
                if (defaultPresetEl) {
                    defaultPresetEl.innerHTML = 'Error loading';
                }
                const defaultApiEl = document.getElementById('default-api-display');
                if (defaultApiEl) {
                    defaultApiEl.innerHTML = 'Error loading';
                }
            }
        }
        
        
        async function loadConfigFileSettings() {
            """Load and display server/channel configs from config file."""
            try {
                const response = await fetch('/api/all_configs');
                const data = await response.json();
                
                const servers = data.servers || [];
                const channels = data.channels || [];
                
                // Load config options
                const presetsResponse = await fetch('/api/presets');
                const presetsData = await presetsResponse.json();
                const presets = presetsData.presets || [];
                
                const apiConfigsResponse = await fetch('/api/api_configs');
                const apiConfigsData = await apiConfigsResponse.json();
                const apiConfigs = apiConfigsData.configs || [];
                
                const charactersResponse = await fetch('/api/characters');
                const charactersData = await charactersResponse.json();
                const characters = charactersData.characters || [];
                
                const listEl = document.getElementById('servers-list');
                listEl.innerHTML = '';
                
                // Show warning
                const warning = document.createElement('div');
                warning.style.cssText = 'background: #fff3cd; border: 2px solid #ffc107; border-radius: 8px; padding: 15px; margin-bottom: 20px;';
                warning.innerHTML = `
                    <h3 style="margin-top: 0; color: #856404;">⚠️ Editing Config File Settings</h3>
                    <p style="color: #856404; margin-bottom: 0;">
                        These are server and channel configurations saved in your config.json file. 
                        Server/channel names are only available when the bot is connected to Discord.
                        <strong>IDs shown below are Discord server/channel IDs.</strong>
                    </p>
                `;
                listEl.appendChild(warning);
                
                // Show server configs
                if (servers.length > 0) {
                    const serversHeader = document.createElement('h3');
                    serversHeader.textContent = '🖥️ Server Configurations';
                    serversHeader.style.marginTop = '20px';
                    listEl.appendChild(serversHeader);
                    
                    servers.forEach((server) => {
                        const serverSection = document.createElement('div');
                        serverSection.style.cssText = 'margin-bottom: 15px; background: white; padding: 20px; border-radius: 8px; border-left: 5px solid #667eea;';
                        
                        serverSection.innerHTML = `
                            <h4 style="margin-top: 0; color: #34495e;">Server ID: ${server.id}</h4>
                            <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 15px; margin-bottom: 10px;">
                                <div>
                                    <label style="display: block; margin-bottom: 5px; font-weight: 600; color: #2c3e50;">Preset</label>
                                    <select id="preset-${server.id}" style="width: 100%; padding: 8px; border: 2px solid #ddd; border-radius: 5px;">
                                        <option value="">Default Preset</option>
                                        ${presets.map(p => `<option value="${p}" ${server.preset === p ? 'selected' : ''}>${p}</option>`).join('')}
                                    </select>
                                </div>
                                <div>
                                    <label style="display: block; margin-bottom: 5px; font-weight: 600; color: #2c3e50;">API Config</label>
                                    <select id="api-config-${server.id}" style="width: 100%; padding: 8px; border: 2px solid #ddd; border-radius: 5px;">
                                        <option value="">Default API Config</option>
                                        ${apiConfigs.map(c => `<option value="${c.name}" ${server.api_config === c.name ? 'selected' : ''}>${c.name}</option>`).join('')}
                                    </select>
                                </div>
                                <div>
                                    <label style="display: block; margin-bottom: 5px; font-weight: 600; color: #2c3e50;">Character</label>
                                    <select id="character-${server.id}" style="width: 100%; padding: 8px; border: 2px solid #ddd; border-radius: 5px;">
                                        <option value="">Default Character</option>
                                        ${characters.map(c => `<option value="${c}" ${server.character === c ? 'selected' : ''}>${c}</option>`).join('')}
                                    </select>
                                </div>
                            </div>
                            <div style="display: flex; gap: 10px;">
                                <button class="btn btn-primary" onclick="saveServerConfigFromFile('${server.id}')">💾 Save</button>
                                <button class="btn btn-danger" onclick="deleteServerConfigFromFile('${server.id}')">🗑️ Delete</button>
                            </div>
                        `;
                        listEl.appendChild(serverSection);
                    });
                }
                
                // Show channel configs
                if (channels.length > 0) {
                    const channelsHeader = document.createElement('h3');
                    channelsHeader.textContent = '💬 Channel Configurations';
                    channelsHeader.style.marginTop = '20px';
                    listEl.appendChild(channelsHeader);
                    
                    channels.forEach((channel) => {
                        const channelSection = document.createElement('div');
                        channelSection.style.cssText = 'margin-bottom: 15px; background: white; padding: 20px; border-radius: 8px; border-left: 5px solid #764ba2;';
                        
                        channelSection.innerHTML = `
                            <h4 style="margin-top: 0; color: #34495e;">Channel ID: ${channel.id}</h4>
                            <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 15px; margin-bottom: 10px;">
                                <div>
                                    <label style="display: block; margin-bottom: 5px; font-weight: 600; color: #2c3e50;">Preset</label>
                                    <select id="preset-channel-${channel.id}" style="width: 100%; padding: 8px; border: 2px solid #ddd; border-radius: 5px;">
                                        <option value="">Default Preset</option>
                                        ${presets.map(p => `<option value="${p}" ${channel.preset === p ? 'selected' : ''}>${p}</option>`).join('')}
                                    </select>
                                </div>
                                <div>
                                    <label style="display: block; margin-bottom: 5px; font-weight: 600; color: #2c3e50;">API Config</label>
                                    <select id="api-config-channel-${channel.id}" style="width: 100%; padding: 8px; border: 2px solid #ddd; border-radius: 5px;">
                                        <option value="">Default API Config</option>
                                        ${apiConfigs.map(c => `<option value="${c.name}" ${channel.api_config === c.name ? 'selected' : ''}>${c.name}</option>`).join('')}
                                    </select>
                                </div>
                                <div>
                                    <label style="display: block; margin-bottom: 5px; font-weight: 600; color: #2c3e50;">Character</label>
                                    <select id="character-channel-${channel.id}" style="width: 100%; padding: 8px; border: 2px solid #ddd; border-radius: 5px;">
                                        <option value="">Default Character</option>
                                        ${characters.map(c => `<option value="${c}" ${channel.character === c ? 'selected' : ''}>${c}</option>`).join('')}
                                    </select>
                                </div>
                            </div>
                            <div style="display: flex; gap: 10px;">
                                <button class="btn btn-primary" onclick="saveChannelConfigFromFile('${channel.id}')">💾 Save</button>
                                <button class="btn btn-danger" onclick="deleteChannelConfigFromFile('${channel.id}')">🗑️ Delete</button>
                            </div>
                        `;
                        listEl.appendChild(channelSection);
                    });
                }
                
                if (servers.length === 0 && channels.length === 0) {
                    const noConfigs = document.createElement('p');
                    noConfigs.style.color = '#666';
                    noConfigs.textContent = 'No server or channel configurations found in config file.';
                    listEl.appendChild(noConfigs);
                }
                
                // Add back button
                const backBtn = document.createElement('button');
                backBtn.className = 'btn btn-secondary';
                backBtn.textContent = '← Back to Servers List';
                backBtn.onclick = loadServersList;
                backBtn.style.marginTop = '20px';
                listEl.appendChild(backBtn);
                
            } catch (error) {
                console.error('Error loading config file settings:', error);
                showMessage('servers-message', 'Error loading config file settings: ' + error.message, 'error');
            }
        }
        
        async function saveServerConfigFromFile(serverId) {
            const preset = document.getElementById(`preset-${serverId}`).value;
            const apiConfig = document.getElementById(`api-config-${serverId}`).value;
            const character = document.getElementById(`character-${serverId}`).value;
            
            try {
                const response = await fetch(`/api/server_config/${serverId}`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({ preset, api_config: apiConfig, character })
                });
                
                const result = await response.json();
                showMessage('servers-message', result.message, result.status === 'success' ? 'success' : 'error');
            } catch (error) {
                showMessage('servers-message', 'Error saving: ' + error.message, 'error');
            }
        }
        
        async function saveChannelConfigFromFile(channelId) {
            const preset = document.getElementById(`preset-channel-${channelId}`).value;
            const apiConfig = document.getElementById(`api-config-channel-${channelId}`).value;
            const character = document.getElementById(`character-channel-${channelId}`).value;
            
            try {
                const response = await fetch(`/api/channel_config/${channelId}`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({ preset, api_config: apiConfig, character })
                });
                
                const result = await response.json();
                showMessage('servers-message', result.message, result.status === 'success' ? 'success' : 'error');
            } catch (error) {
                showMessage('servers-message', 'Error saving: ' + error.message, 'error');
            }
        }
        
        async function deleteServerConfigFromFile(serverId) {
            if (!confirm(`Delete configuration for server ${serverId}?`)) {
                return;
            }
            
            try {
                const response = await fetch(`/api/server_config/${serverId}`, {
                    method: 'DELETE'
                });
                
                const result = await response.json();
                showMessage('servers-message', result.message, result.status === 'success' ? 'success' : 'error');
                
                if (result.status === 'success') {
                    loadConfigFileSettings(); // Reload the list
                }
            } catch (error) {
                showMessage('servers-message', 'Error deleting: ' + error.message, 'error');
            }
        }
        
        async function deleteChannelConfigFromFile(channelId) {
            if (!confirm(`Delete configuration for channel ${channelId}?`)) {
                return;
            }
            
            try {
                const response = await fetch(`/api/channel_config/${channelId}`, {
                    method: 'DELETE'
                });
                
                const result = await response.json();
                showMessage('servers-message', result.message, result.status === 'success' ? 'success' : 'error');
                
                if (result.status === 'success') {
                    loadConfigFileSettings(); // Reload the list
                }
            } catch (error) {
                showMessage('servers-message', 'Error deleting: ' + error.message, 'error');
            }
        }
        
        async function loadServersList() {
            try {
                // Load default configuration first (don't let errors block server loading)
                try {
                    await loadDefaultConfig();
                } catch (configError) {
                    console.error('Error loading default config (non-fatal):', configError);
                }
                
                const response = await fetch('/api/servers');
                const data = await response.json();
                const servers = data.servers || [];
                
                const listEl = document.getElementById('servers-list');
                
                if (servers.length === 0) {
                    // Bot not connected - show configs from config file instead
                    listEl.innerHTML = `
                        <div style="background: #fff3cd; border: 2px solid #ffc107; border-radius: 8px; padding: 20px; margin-bottom: 20px;">
                            <h3 style="margin-top: 0; color: #856404;">⚠️ Bot Not Connected to Discord</h3>
                            <p style="color: #856404;">
                                The bot is not currently connected to Discord, so server and channel names are not available. 
                                However, you can still manage configurations saved in your config file.
                            </p>
                            <button class="btn btn-primary" onclick="loadConfigFileSettings()" style="margin-top: 10px;">
                                📁 View/Edit Config File Settings
                            </button>
                        </div>
                    `;
                    return;
                }
                
                // Load config options once (presets, API configs, characters)
                const presetsResponse = await fetch('/api/presets');
                const presetsData = await presetsResponse.json();
                const presets = presetsData.presets || [];
                
                const apiConfigsResponse = await fetch('/api/api_configs');
                const apiConfigsData = await apiConfigsResponse.json();
                const apiConfigs = apiConfigsData.configs || [];
                
                const charactersResponse = await fetch('/api/characters');
                const charactersData = await charactersResponse.json();
                const characters = charactersData.characters || [];
                
                listEl.innerHTML = '';
                
                servers.forEach((server) => {
                    const serverSection = document.createElement('div');
                    serverSection.style.cssText = 'margin-bottom: 15px; background: white; padding: 20px; border-radius: 8px; border-left: 5px solid #667eea;';
                    
                    // Safely get channel count, default to 0 if not present
                    const channelCount = server.channel_count || 0;
                    
                    serverSection.innerHTML = `
                        <h3 style="margin-top: 0; color: #34495e;">🖥️ ${server.name} <span style="font-size: 0.8em; color: #666;">(${channelCount} channels)</span></h3>
                        <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 15px; margin-bottom: 10px;">
                            <div>
                                <label style="display: block; margin-bottom: 5px; font-weight: 600; color: #2c3e50;">Preset</label>
                                <select id="preset-${server.id}" style="width: 100%; padding: 8px; border: 2px solid #ddd; border-radius: 5px;">
                                    <option value="">Default Preset</option>
                                    ${presets.map(p => `<option value="${p}" ${server.preset === p ? 'selected' : ''}>${p}</option>`).join('')}
                                </select>
                            </div>
                            <div>
                                <label style="display: block; margin-bottom: 5px; font-weight: 600; color: #2c3e50;">API Config</label>
                                <select id="api-${server.id}" style="width: 100%; padding: 8px; border: 2px solid #ddd; border-radius: 5px;">
                                    <option value="">Default API Config</option>
                                    ${apiConfigs.map(cfg => `<option value="${cfg.name}" ${server.api_config === cfg.name ? 'selected' : ''}>${cfg.display || cfg.name}</option>`).join('')}
                                </select>
                            </div>
                            <div>
                                <label style="display: block; margin-bottom: 5px; font-weight: 600; color: #2c3e50;">Character</label>
                                <select id="character-${server.id}" style="width: 100%; padding: 8px; border: 2px solid #ddd; border-radius: 5px;">
                                    <option value="">No Character</option>
                                    ${characters.map(c => `<option value="${c}" ${server.character === c ? 'selected' : ''}>${c}</option>`).join('')}
                                </select>
                            </div>
                        </div>
                        <button class="btn btn-primary btn-sm" onclick="saveServerConfig('${server.id}')">💾 Save Configuration</button>
                    `;
                    
                    listEl.appendChild(serverSection);
                });
                
                showMessage('servers-message', `Loaded ${servers.length} server(s)`, 'success');
            } catch (error) {
                showMessage('servers-message', 'Error loading servers: ' + error.message, 'error');
            }
        }
        
        async function saveServerConfig(serverId) {
            try {
                const preset = document.getElementById(`preset-${serverId}`).value;
                const apiConfig = document.getElementById(`api-${serverId}`).value;
                const character = document.getElementById(`character-${serverId}`).value;
                
                const response = await fetch(`/api/server_config/${serverId}`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        preset: preset,
                        api_config: apiConfig,
                        character: character
                    })
                });
                
                const result = await response.json();
                showMessage('servers-message', result.message, result.status === 'success' ? 'success' : 'error');
            } catch (error) {
                showMessage('servers-message', 'Error saving server configuration: ' + error.message, 'error');
            }
        }
        
        // Load config on page load
        window.onload = function() {
            loadConfig();
            loadSavedApiConfigs();
            loadPresetsDropdown();
            // Initialize with one default system section
            loadPromptSections([]);
        };
    </script>
</body>
</html>
